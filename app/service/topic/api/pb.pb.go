// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pb.proto

package api

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// EmptyStruct 空的message，对应真实service只返回error，没有具体返回值
type EmptyStruct struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EmptyStruct) Reset()         { *m = EmptyStruct{} }
func (m *EmptyStruct) String() string { return proto.CompactTextString(m) }
func (*EmptyStruct) ProtoMessage()    {}
func (*EmptyStruct) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{0}
}
func (m *EmptyStruct) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EmptyStruct) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EmptyStruct.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EmptyStruct) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EmptyStruct.Merge(m, src)
}
func (m *EmptyStruct) XXX_Size() int {
	return m.Size()
}
func (m *EmptyStruct) XXX_DiscardUnknown() {
	xxx_messageInfo_EmptyStruct.DiscardUnknown(m)
}

var xxx_messageInfo_EmptyStruct proto.InternalMessageInfo

type MemberRoleReply struct {
	IsMember             bool     `protobuf:"varint,1,opt,name=IsMember,proto3" json:"is_member"`
	Role                 string   `protobuf:"bytes,2,opt,name=Role,proto3" json:"role"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MemberRoleReply) Reset()         { *m = MemberRoleReply{} }
func (m *MemberRoleReply) String() string { return proto.CompactTextString(m) }
func (*MemberRoleReply) ProtoMessage()    {}
func (*MemberRoleReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{1}
}
func (m *MemberRoleReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MemberRoleReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MemberRoleReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MemberRoleReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MemberRoleReply.Merge(m, src)
}
func (m *MemberRoleReply) XXX_Size() int {
	return m.Size()
}
func (m *MemberRoleReply) XXX_DiscardUnknown() {
	xxx_messageInfo_MemberRoleReply.DiscardUnknown(m)
}

var xxx_messageInfo_MemberRoleReply proto.InternalMessageInfo

func (m *MemberRoleReply) GetIsMember() bool {
	if m != nil {
		return m.IsMember
	}
	return false
}

func (m *MemberRoleReply) GetRole() string {
	if m != nil {
		return m.Role
	}
	return ""
}

type Creator struct {
	ID                   int64    `protobuf:"varint,1,opt,name=ID,proto3" json:"id"`
	UserName             string   `protobuf:"bytes,2,opt,name=UserName,proto3" json:"user_name"`
	Avatar               string   `protobuf:"bytes,3,opt,name=Avatar,proto3" json:"avatar"`
	Introduction         string   `protobuf:"bytes,4,opt,name=Introduction,proto3" json:"introduction"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Creator) Reset()         { *m = Creator{} }
func (m *Creator) String() string { return proto.CompactTextString(m) }
func (*Creator) ProtoMessage()    {}
func (*Creator) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{2}
}
func (m *Creator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Creator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Creator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Creator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Creator.Merge(m, src)
}
func (m *Creator) XXX_Size() int {
	return m.Size()
}
func (m *Creator) XXX_DiscardUnknown() {
	xxx_messageInfo_Creator.DiscardUnknown(m)
}

var xxx_messageInfo_Creator proto.InternalMessageInfo

func (m *Creator) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Creator) GetUserName() string {
	if m != nil {
		return m.UserName
	}
	return ""
}

func (m *Creator) GetAvatar() string {
	if m != nil {
		return m.Avatar
	}
	return ""
}

func (m *Creator) GetIntroduction() string {
	if m != nil {
		return m.Introduction
	}
	return ""
}

type TopicInfo struct {
	ID              int64    `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Name            string   `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
	Avatar          string   `protobuf:"bytes,3,opt,name=Avatar,proto3" json:"Avatar,omitempty"`
	Bg              string   `protobuf:"bytes,4,opt,name=Bg,proto3" json:"Bg,omitempty"`
	Introduction    string   `protobuf:"bytes,5,opt,name=Introduction,proto3" json:"Introduction,omitempty"`
	AllowDiscuss    bool     `protobuf:"varint,6,opt,name=AllowDiscuss,proto3" json:"AllowDiscuss,omitempty"`
	AllowChat       bool     `protobuf:"varint,7,opt,name=AllowChat,proto3" json:"AllowChat,omitempty"`
	IsPrivate       bool     `protobuf:"varint,8,opt,name=IsPrivate,proto3" json:"IsPrivate,omitempty"`
	ViewPermission  string   `protobuf:"bytes,9,opt,name=ViewPermission,proto3" json:"ViewPermission,omitempty"`
	EditPermission  string   `protobuf:"bytes,10,opt,name=EditPermission,proto3" json:"EditPermission,omitempty"`
	JoinPermission  string   `protobuf:"bytes,11,opt,name=JoinPermission,proto3" json:"JoinPermission,omitempty"`
	CatalogViewType string   `protobuf:"bytes,12,opt,name=CatalogViewType,proto3" json:"CatalogViewType,omitempty"`
	TopicHome       string   `protobuf:"bytes,13,opt,name=TopicHome,proto3" json:"TopicHome,omitempty"`
	Creator         *Creator `protobuf:"bytes,14,opt,name=Creator,proto3" json:"Creator,omitempty"`
	// unix timestamp
	CreatedAt int64 `protobuf:"varint,15,opt,name=CreatedAt,proto3" json:"CreatedAt,omitempty"`
	// unix timestamp
	UpdatedAt            int64      `protobuf:"varint,16,opt,name=UpdatedAt,proto3" json:"UpdatedAt,omitempty"`
	Stat                 *TopicStat `protobuf:"bytes,17,opt,name=Stat,proto3" json:"Stat,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *TopicInfo) Reset()         { *m = TopicInfo{} }
func (m *TopicInfo) String() string { return proto.CompactTextString(m) }
func (*TopicInfo) ProtoMessage()    {}
func (*TopicInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{3}
}
func (m *TopicInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TopicInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TopicInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TopicInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TopicInfo.Merge(m, src)
}
func (m *TopicInfo) XXX_Size() int {
	return m.Size()
}
func (m *TopicInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TopicInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TopicInfo proto.InternalMessageInfo

func (m *TopicInfo) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *TopicInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TopicInfo) GetAvatar() string {
	if m != nil {
		return m.Avatar
	}
	return ""
}

func (m *TopicInfo) GetBg() string {
	if m != nil {
		return m.Bg
	}
	return ""
}

func (m *TopicInfo) GetIntroduction() string {
	if m != nil {
		return m.Introduction
	}
	return ""
}

func (m *TopicInfo) GetAllowDiscuss() bool {
	if m != nil {
		return m.AllowDiscuss
	}
	return false
}

func (m *TopicInfo) GetAllowChat() bool {
	if m != nil {
		return m.AllowChat
	}
	return false
}

func (m *TopicInfo) GetIsPrivate() bool {
	if m != nil {
		return m.IsPrivate
	}
	return false
}

func (m *TopicInfo) GetViewPermission() string {
	if m != nil {
		return m.ViewPermission
	}
	return ""
}

func (m *TopicInfo) GetEditPermission() string {
	if m != nil {
		return m.EditPermission
	}
	return ""
}

func (m *TopicInfo) GetJoinPermission() string {
	if m != nil {
		return m.JoinPermission
	}
	return ""
}

func (m *TopicInfo) GetCatalogViewType() string {
	if m != nil {
		return m.CatalogViewType
	}
	return ""
}

func (m *TopicInfo) GetTopicHome() string {
	if m != nil {
		return m.TopicHome
	}
	return ""
}

func (m *TopicInfo) GetCreator() *Creator {
	if m != nil {
		return m.Creator
	}
	return nil
}

func (m *TopicInfo) GetCreatedAt() int64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

func (m *TopicInfo) GetUpdatedAt() int64 {
	if m != nil {
		return m.UpdatedAt
	}
	return 0
}

func (m *TopicInfo) GetStat() *TopicStat {
	if m != nil {
		return m.Stat
	}
	return nil
}

type TopicRootCatalogInfo struct {
	ID                   int64                     `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Name                 string                    `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
	Seq                  int32                     `protobuf:"varint,3,opt,name=Seq,proto3" json:"Seq,omitempty"`
	Type                 string                    `protobuf:"bytes,4,opt,name=Type,proto3" json:"Type,omitempty"`
	RefID                int64                     `protobuf:"varint,6,opt,name=RefID,proto3" json:"RefID,omitempty"`
	Article              *TargetArticle            `protobuf:"bytes,7,opt,name=Article,proto3" json:"Article,omitempty"`
	Children             []*TopicParentCatalogInfo `protobuf:"bytes,8,rep,name=Children,proto3" json:"Children,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *TopicRootCatalogInfo) Reset()         { *m = TopicRootCatalogInfo{} }
func (m *TopicRootCatalogInfo) String() string { return proto.CompactTextString(m) }
func (*TopicRootCatalogInfo) ProtoMessage()    {}
func (*TopicRootCatalogInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{4}
}
func (m *TopicRootCatalogInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TopicRootCatalogInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TopicRootCatalogInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TopicRootCatalogInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TopicRootCatalogInfo.Merge(m, src)
}
func (m *TopicRootCatalogInfo) XXX_Size() int {
	return m.Size()
}
func (m *TopicRootCatalogInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TopicRootCatalogInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TopicRootCatalogInfo proto.InternalMessageInfo

func (m *TopicRootCatalogInfo) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *TopicRootCatalogInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TopicRootCatalogInfo) GetSeq() int32 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *TopicRootCatalogInfo) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *TopicRootCatalogInfo) GetRefID() int64 {
	if m != nil {
		return m.RefID
	}
	return 0
}

func (m *TopicRootCatalogInfo) GetArticle() *TargetArticle {
	if m != nil {
		return m.Article
	}
	return nil
}

func (m *TopicRootCatalogInfo) GetChildren() []*TopicParentCatalogInfo {
	if m != nil {
		return m.Children
	}
	return nil
}

type TopicParentCatalogInfo struct {
	ID                   int64                    `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Name                 string                   `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
	Seq                  int32                    `protobuf:"varint,3,opt,name=Seq,proto3" json:"Seq,omitempty"`
	Type                 string                   `protobuf:"bytes,4,opt,name=Type,proto3" json:"Type,omitempty"`
	RefID                int64                    `protobuf:"varint,5,opt,name=RefID,proto3" json:"RefID,omitempty"`
	Article              *TargetArticle           `protobuf:"bytes,7,opt,name=Article,proto3" json:"Article,omitempty"`
	Children             []*TopicChildCatalogInfo `protobuf:"bytes,8,rep,name=Children,proto3" json:"Children,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *TopicParentCatalogInfo) Reset()         { *m = TopicParentCatalogInfo{} }
func (m *TopicParentCatalogInfo) String() string { return proto.CompactTextString(m) }
func (*TopicParentCatalogInfo) ProtoMessage()    {}
func (*TopicParentCatalogInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{5}
}
func (m *TopicParentCatalogInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TopicParentCatalogInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TopicParentCatalogInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TopicParentCatalogInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TopicParentCatalogInfo.Merge(m, src)
}
func (m *TopicParentCatalogInfo) XXX_Size() int {
	return m.Size()
}
func (m *TopicParentCatalogInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TopicParentCatalogInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TopicParentCatalogInfo proto.InternalMessageInfo

func (m *TopicParentCatalogInfo) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *TopicParentCatalogInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TopicParentCatalogInfo) GetSeq() int32 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *TopicParentCatalogInfo) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *TopicParentCatalogInfo) GetRefID() int64 {
	if m != nil {
		return m.RefID
	}
	return 0
}

func (m *TopicParentCatalogInfo) GetArticle() *TargetArticle {
	if m != nil {
		return m.Article
	}
	return nil
}

func (m *TopicParentCatalogInfo) GetChildren() []*TopicChildCatalogInfo {
	if m != nil {
		return m.Children
	}
	return nil
}

type TopicChildCatalogInfo struct {
	ID                   int64          `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Name                 string         `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
	Seq                  int32          `protobuf:"varint,3,opt,name=Seq,proto3" json:"Seq,omitempty"`
	Type                 string         `protobuf:"bytes,4,opt,name=Type,proto3" json:"Type,omitempty"`
	RefID                int64          `protobuf:"varint,5,opt,name=RefID,proto3" json:"RefID,omitempty"`
	Article              *TargetArticle `protobuf:"bytes,7,opt,name=Article,proto3" json:"Article,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *TopicChildCatalogInfo) Reset()         { *m = TopicChildCatalogInfo{} }
func (m *TopicChildCatalogInfo) String() string { return proto.CompactTextString(m) }
func (*TopicChildCatalogInfo) ProtoMessage()    {}
func (*TopicChildCatalogInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{6}
}
func (m *TopicChildCatalogInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TopicChildCatalogInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TopicChildCatalogInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TopicChildCatalogInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TopicChildCatalogInfo.Merge(m, src)
}
func (m *TopicChildCatalogInfo) XXX_Size() int {
	return m.Size()
}
func (m *TopicChildCatalogInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TopicChildCatalogInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TopicChildCatalogInfo proto.InternalMessageInfo

func (m *TopicChildCatalogInfo) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *TopicChildCatalogInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TopicChildCatalogInfo) GetSeq() int32 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *TopicChildCatalogInfo) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *TopicChildCatalogInfo) GetRefID() int64 {
	if m != nil {
		return m.RefID
	}
	return 0
}

func (m *TopicChildCatalogInfo) GetArticle() *TargetArticle {
	if m != nil {
		return m.Article
	}
	return nil
}

type TargetArticle struct {
	ID                   int64    `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Title                string   `protobuf:"bytes,2,opt,name=Title,proto3" json:"Title,omitempty"`
	Excerpt              string   `protobuf:"bytes,3,opt,name=Excerpt,proto3" json:"Excerpt,omitempty"`
	ImageUrls            []string `protobuf:"bytes,4,rep,name=ImageUrls,proto3" json:"ImageUrls,omitempty"`
	LikeCount            int32    `protobuf:"varint,5,opt,name=LikeCount,proto3" json:"LikeCount,omitempty"`
	DislikeCount         int32    `protobuf:"varint,6,opt,name=DislikeCount,proto3" json:"DislikeCount,omitempty"`
	ReviseCount          int32    `protobuf:"varint,7,opt,name=ReviseCount,proto3" json:"ReviseCount,omitempty"`
	CommentCount         int32    `protobuf:"varint,8,opt,name=CommentCount,proto3" json:"CommentCount,omitempty"`
	CreatedAt            int64    `protobuf:"varint,9,opt,name=CreatedAt,proto3" json:"CreatedAt,omitempty"`
	UpdatedAt            int64    `protobuf:"varint,10,opt,name=UpdatedAt,proto3" json:"UpdatedAt,omitempty"`
	Creator              *Creator `protobuf:"bytes,11,opt,name=Creator,proto3" json:"Creator,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TargetArticle) Reset()         { *m = TargetArticle{} }
func (m *TargetArticle) String() string { return proto.CompactTextString(m) }
func (*TargetArticle) ProtoMessage()    {}
func (*TargetArticle) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{7}
}
func (m *TargetArticle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TargetArticle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TargetArticle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TargetArticle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TargetArticle.Merge(m, src)
}
func (m *TargetArticle) XXX_Size() int {
	return m.Size()
}
func (m *TargetArticle) XXX_DiscardUnknown() {
	xxx_messageInfo_TargetArticle.DiscardUnknown(m)
}

var xxx_messageInfo_TargetArticle proto.InternalMessageInfo

func (m *TargetArticle) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *TargetArticle) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *TargetArticle) GetExcerpt() string {
	if m != nil {
		return m.Excerpt
	}
	return ""
}

func (m *TargetArticle) GetImageUrls() []string {
	if m != nil {
		return m.ImageUrls
	}
	return nil
}

func (m *TargetArticle) GetLikeCount() int32 {
	if m != nil {
		return m.LikeCount
	}
	return 0
}

func (m *TargetArticle) GetDislikeCount() int32 {
	if m != nil {
		return m.DislikeCount
	}
	return 0
}

func (m *TargetArticle) GetReviseCount() int32 {
	if m != nil {
		return m.ReviseCount
	}
	return 0
}

func (m *TargetArticle) GetCommentCount() int32 {
	if m != nil {
		return m.CommentCount
	}
	return 0
}

func (m *TargetArticle) GetCreatedAt() int64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

func (m *TargetArticle) GetUpdatedAt() int64 {
	if m != nil {
		return m.UpdatedAt
	}
	return 0
}

func (m *TargetArticle) GetCreator() *Creator {
	if m != nil {
		return m.Creator
	}
	return nil
}

type TopicStat struct {
	MemberCount          int32    `protobuf:"varint,1,opt,name=MemberCount,proto3" json:"member_count"`
	ArticleCount         int32    `protobuf:"varint,2,opt,name=ArticleCount,proto3" json:"article_count"`
	DiscussionCount      int32    `protobuf:"varint,3,opt,name=DiscussionCount,proto3" json:"discussion_count"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TopicStat) Reset()         { *m = TopicStat{} }
func (m *TopicStat) String() string { return proto.CompactTextString(m) }
func (*TopicStat) ProtoMessage()    {}
func (*TopicStat) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{8}
}
func (m *TopicStat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TopicStat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TopicStat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TopicStat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TopicStat.Merge(m, src)
}
func (m *TopicStat) XXX_Size() int {
	return m.Size()
}
func (m *TopicStat) XXX_DiscardUnknown() {
	xxx_messageInfo_TopicStat.DiscardUnknown(m)
}

var xxx_messageInfo_TopicStat proto.InternalMessageInfo

func (m *TopicStat) GetMemberCount() int32 {
	if m != nil {
		return m.MemberCount
	}
	return 0
}

func (m *TopicStat) GetArticleCount() int32 {
	if m != nil {
		return m.ArticleCount
	}
	return 0
}

func (m *TopicStat) GetDiscussionCount() int32 {
	if m != nil {
		return m.DiscussionCount
	}
	return 0
}

type TopicMetaInfo struct {
	CanFollow            bool     `protobuf:"varint,1,opt,name=CanFollow,proto3" json:"can_follow"`
	CanEdit              bool     `protobuf:"varint,2,opt,name=CanEdit,proto3" json:"can_edit"`
	Fav                  bool     `protobuf:"varint,3,opt,name=Fav,proto3" json:"fav"`
	CanView              bool     `protobuf:"varint,4,opt,name=CanView,proto3" json:"can_view"`
	FollowStatus         int32    `protobuf:"varint,5,opt,name=FollowStatus,proto3" json:"follow_status"`
	IsMember             bool     `protobuf:"varint,6,opt,name=IsMember,proto3" json:"is_member"`
	MemberRole           string   `protobuf:"bytes,7,opt,name=MemberRole,proto3" json:"member_role"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TopicMetaInfo) Reset()         { *m = TopicMetaInfo{} }
func (m *TopicMetaInfo) String() string { return proto.CompactTextString(m) }
func (*TopicMetaInfo) ProtoMessage()    {}
func (*TopicMetaInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{9}
}
func (m *TopicMetaInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TopicMetaInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TopicMetaInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TopicMetaInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TopicMetaInfo.Merge(m, src)
}
func (m *TopicMetaInfo) XXX_Size() int {
	return m.Size()
}
func (m *TopicMetaInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TopicMetaInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TopicMetaInfo proto.InternalMessageInfo

func (m *TopicMetaInfo) GetCanFollow() bool {
	if m != nil {
		return m.CanFollow
	}
	return false
}

func (m *TopicMetaInfo) GetCanEdit() bool {
	if m != nil {
		return m.CanEdit
	}
	return false
}

func (m *TopicMetaInfo) GetFav() bool {
	if m != nil {
		return m.Fav
	}
	return false
}

func (m *TopicMetaInfo) GetCanView() bool {
	if m != nil {
		return m.CanView
	}
	return false
}

func (m *TopicMetaInfo) GetFollowStatus() int32 {
	if m != nil {
		return m.FollowStatus
	}
	return 0
}

func (m *TopicMetaInfo) GetIsMember() bool {
	if m != nil {
		return m.IsMember
	}
	return false
}

func (m *TopicMetaInfo) GetMemberRole() string {
	if m != nil {
		return m.MemberRole
	}
	return ""
}

type TopicPermissionInfo struct {
	EditPermission       string   `protobuf:"bytes,1,opt,name=EditPermission,proto3" json:"edit_permission"`
	IsMember             bool     `protobuf:"varint,2,opt,name=IsMember,proto3" json:"is_member"`
	MemberRole           string   `protobuf:"bytes,3,opt,name=MemberRole,proto3" json:"member_role"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TopicPermissionInfo) Reset()         { *m = TopicPermissionInfo{} }
func (m *TopicPermissionInfo) String() string { return proto.CompactTextString(m) }
func (*TopicPermissionInfo) ProtoMessage()    {}
func (*TopicPermissionInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{10}
}
func (m *TopicPermissionInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TopicPermissionInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TopicPermissionInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TopicPermissionInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TopicPermissionInfo.Merge(m, src)
}
func (m *TopicPermissionInfo) XXX_Size() int {
	return m.Size()
}
func (m *TopicPermissionInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TopicPermissionInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TopicPermissionInfo proto.InternalMessageInfo

func (m *TopicPermissionInfo) GetEditPermission() string {
	if m != nil {
		return m.EditPermission
	}
	return ""
}

func (m *TopicPermissionInfo) GetIsMember() bool {
	if m != nil {
		return m.IsMember
	}
	return false
}

func (m *TopicPermissionInfo) GetMemberRole() string {
	if m != nil {
		return m.MemberRole
	}
	return ""
}

type TopicReq struct {
	ID                   int64    `protobuf:"varint,1,opt,name=ID,proto3" json:"id"`
	UseMaster            bool     `protobuf:"varint,2,opt,name=UseMaster,proto3" json:"UseMaster,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TopicReq) Reset()         { *m = TopicReq{} }
func (m *TopicReq) String() string { return proto.CompactTextString(m) }
func (*TopicReq) ProtoMessage()    {}
func (*TopicReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{11}
}
func (m *TopicReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TopicReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TopicReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TopicReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TopicReq.Merge(m, src)
}
func (m *TopicReq) XXX_Size() int {
	return m.Size()
}
func (m *TopicReq) XXX_DiscardUnknown() {
	xxx_messageInfo_TopicReq.DiscardUnknown(m)
}

var xxx_messageInfo_TopicReq proto.InternalMessageInfo

func (m *TopicReq) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *TopicReq) GetUseMaster() bool {
	if m != nil {
		return m.UseMaster
	}
	return false
}

type TopicMetaReq struct {
	TopicID              int64    `protobuf:"varint,1,opt,name=TopicID,proto3" json:"topic_id"`
	AccountID            int64    `protobuf:"varint,2,opt,name=AccountID,proto3" json:"aid"`
	UseMaster            bool     `protobuf:"varint,3,opt,name=UseMaster,proto3" json:"UseMaster,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TopicMetaReq) Reset()         { *m = TopicMetaReq{} }
func (m *TopicMetaReq) String() string { return proto.CompactTextString(m) }
func (*TopicMetaReq) ProtoMessage()    {}
func (*TopicMetaReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{12}
}
func (m *TopicMetaReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TopicMetaReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TopicMetaReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TopicMetaReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TopicMetaReq.Merge(m, src)
}
func (m *TopicMetaReq) XXX_Size() int {
	return m.Size()
}
func (m *TopicMetaReq) XXX_DiscardUnknown() {
	xxx_messageInfo_TopicMetaReq.DiscardUnknown(m)
}

var xxx_messageInfo_TopicMetaReq proto.InternalMessageInfo

func (m *TopicMetaReq) GetTopicID() int64 {
	if m != nil {
		return m.TopicID
	}
	return 0
}

func (m *TopicMetaReq) GetAccountID() int64 {
	if m != nil {
		return m.AccountID
	}
	return 0
}

func (m *TopicMetaReq) GetUseMaster() bool {
	if m != nil {
		return m.UseMaster
	}
	return false
}

type TopicMemberRoleReq struct {
	TopicID              int64    `protobuf:"varint,1,opt,name=TopicID,proto3" json:"topic_id"`
	AccountID            int64    `protobuf:"varint,2,opt,name=AccountID,proto3" json:"aid"`
	UseMaster            bool     `protobuf:"varint,3,opt,name=UseMaster,proto3" json:"UseMaster,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TopicMemberRoleReq) Reset()         { *m = TopicMemberRoleReq{} }
func (m *TopicMemberRoleReq) String() string { return proto.CompactTextString(m) }
func (*TopicMemberRoleReq) ProtoMessage()    {}
func (*TopicMemberRoleReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{13}
}
func (m *TopicMemberRoleReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TopicMemberRoleReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TopicMemberRoleReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TopicMemberRoleReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TopicMemberRoleReq.Merge(m, src)
}
func (m *TopicMemberRoleReq) XXX_Size() int {
	return m.Size()
}
func (m *TopicMemberRoleReq) XXX_DiscardUnknown() {
	xxx_messageInfo_TopicMemberRoleReq.DiscardUnknown(m)
}

var xxx_messageInfo_TopicMemberRoleReq proto.InternalMessageInfo

func (m *TopicMemberRoleReq) GetTopicID() int64 {
	if m != nil {
		return m.TopicID
	}
	return 0
}

func (m *TopicMemberRoleReq) GetAccountID() int64 {
	if m != nil {
		return m.AccountID
	}
	return 0
}

func (m *TopicMemberRoleReq) GetUseMaster() bool {
	if m != nil {
		return m.UseMaster
	}
	return false
}

type TopicPermissionReq struct {
	TopicID              int64    `protobuf:"varint,1,opt,name=TopicID,proto3" json:"topic_id"`
	AccountID            int64    `protobuf:"varint,2,opt,name=AccountID,proto3" json:"aid"`
	UseMaster            bool     `protobuf:"varint,3,opt,name=UseMaster,proto3" json:"UseMaster,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TopicPermissionReq) Reset()         { *m = TopicPermissionReq{} }
func (m *TopicPermissionReq) String() string { return proto.CompactTextString(m) }
func (*TopicPermissionReq) ProtoMessage()    {}
func (*TopicPermissionReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{14}
}
func (m *TopicPermissionReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TopicPermissionReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TopicPermissionReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TopicPermissionReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TopicPermissionReq.Merge(m, src)
}
func (m *TopicPermissionReq) XXX_Size() int {
	return m.Size()
}
func (m *TopicPermissionReq) XXX_DiscardUnknown() {
	xxx_messageInfo_TopicPermissionReq.DiscardUnknown(m)
}

var xxx_messageInfo_TopicPermissionReq proto.InternalMessageInfo

func (m *TopicPermissionReq) GetTopicID() int64 {
	if m != nil {
		return m.TopicID
	}
	return 0
}

func (m *TopicPermissionReq) GetAccountID() int64 {
	if m != nil {
		return m.AccountID
	}
	return 0
}

func (m *TopicPermissionReq) GetUseMaster() bool {
	if m != nil {
		return m.UseMaster
	}
	return false
}

type UserTopicsReq struct {
	AccountID            int64    `protobuf:"varint,1,opt,name=AccountID,proto3" json:"aid"`
	Limit                int32    `protobuf:"varint,2,opt,name=Limit,proto3" json:"limit"`
	Offset               int32    `protobuf:"varint,3,opt,name=Offset,proto3" json:"offset"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserTopicsReq) Reset()         { *m = UserTopicsReq{} }
func (m *UserTopicsReq) String() string { return proto.CompactTextString(m) }
func (*UserTopicsReq) ProtoMessage()    {}
func (*UserTopicsReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{15}
}
func (m *UserTopicsReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserTopicsReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserTopicsReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserTopicsReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserTopicsReq.Merge(m, src)
}
func (m *UserTopicsReq) XXX_Size() int {
	return m.Size()
}
func (m *UserTopicsReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UserTopicsReq.DiscardUnknown(m)
}

var xxx_messageInfo_UserTopicsReq proto.InternalMessageInfo

func (m *UserTopicsReq) GetAccountID() int64 {
	if m != nil {
		return m.AccountID
	}
	return 0
}

func (m *UserTopicsReq) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *UserTopicsReq) GetOffset() int32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

type UserTopicsResp struct {
	Items                []*TopicInfo `protobuf:"bytes,1,rep,name=Items,proto3" json:"items"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *UserTopicsResp) Reset()         { *m = UserTopicsResp{} }
func (m *UserTopicsResp) String() string { return proto.CompactTextString(m) }
func (*UserTopicsResp) ProtoMessage()    {}
func (*UserTopicsResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{16}
}
func (m *UserTopicsResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserTopicsResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserTopicsResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserTopicsResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserTopicsResp.Merge(m, src)
}
func (m *UserTopicsResp) XXX_Size() int {
	return m.Size()
}
func (m *UserTopicsResp) XXX_DiscardUnknown() {
	xxx_messageInfo_UserTopicsResp.DiscardUnknown(m)
}

var xxx_messageInfo_UserTopicsResp proto.InternalMessageInfo

func (m *UserTopicsResp) GetItems() []*TopicInfo {
	if m != nil {
		return m.Items
	}
	return nil
}

type AllTopicsResp struct {
	Items                []*TopicInfo `protobuf:"bytes,1,rep,name=Items,proto3" json:"items"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *AllTopicsResp) Reset()         { *m = AllTopicsResp{} }
func (m *AllTopicsResp) String() string { return proto.CompactTextString(m) }
func (*AllTopicsResp) ProtoMessage()    {}
func (*AllTopicsResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{17}
}
func (m *AllTopicsResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllTopicsResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AllTopicsResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AllTopicsResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllTopicsResp.Merge(m, src)
}
func (m *AllTopicsResp) XXX_Size() int {
	return m.Size()
}
func (m *AllTopicsResp) XXX_DiscardUnknown() {
	xxx_messageInfo_AllTopicsResp.DiscardUnknown(m)
}

var xxx_messageInfo_AllTopicsResp proto.InternalMessageInfo

func (m *AllTopicsResp) GetItems() []*TopicInfo {
	if m != nil {
		return m.Items
	}
	return nil
}

type AidReq struct {
	AccountID            int64    `protobuf:"varint,1,opt,name=AccountID,proto3" json:"account_id"`
	UseMaster            bool     `protobuf:"varint,2,opt,name=UseMaster,proto3" json:"UseMaster,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AidReq) Reset()         { *m = AidReq{} }
func (m *AidReq) String() string { return proto.CompactTextString(m) }
func (*AidReq) ProtoMessage()    {}
func (*AidReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{18}
}
func (m *AidReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AidReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AidReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AidReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AidReq.Merge(m, src)
}
func (m *AidReq) XXX_Size() int {
	return m.Size()
}
func (m *AidReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AidReq.DiscardUnknown(m)
}

var xxx_messageInfo_AidReq proto.InternalMessageInfo

func (m *AidReq) GetAccountID() int64 {
	if m != nil {
		return m.AccountID
	}
	return 0
}

func (m *AidReq) GetUseMaster() bool {
	if m != nil {
		return m.UseMaster
	}
	return false
}

type IDsResp struct {
	IDs                  []int64  `protobuf:"varint,1,rep,packed,name=IDs,proto3" json:"ids"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IDsResp) Reset()         { *m = IDsResp{} }
func (m *IDsResp) String() string { return proto.CompactTextString(m) }
func (*IDsResp) ProtoMessage()    {}
func (*IDsResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{19}
}
func (m *IDsResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IDsResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IDsResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IDsResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IDsResp.Merge(m, src)
}
func (m *IDsResp) XXX_Size() int {
	return m.Size()
}
func (m *IDsResp) XXX_DiscardUnknown() {
	xxx_messageInfo_IDsResp.DiscardUnknown(m)
}

var xxx_messageInfo_IDsResp proto.InternalMessageInfo

func (m *IDsResp) GetIDs() []int64 {
	if m != nil {
		return m.IDs
	}
	return nil
}

type IDReq struct {
	ID                   int64    `protobuf:"varint,1,opt,name=ID,proto3" json:"id"`
	Include              string   `protobuf:"bytes,2,opt,name=Include,proto3" json:"Include,omitempty"`
	Aid                  int64    `protobuf:"varint,3,opt,name=Aid,proto3" json:"Aid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IDReq) Reset()         { *m = IDReq{} }
func (m *IDReq) String() string { return proto.CompactTextString(m) }
func (*IDReq) ProtoMessage()    {}
func (*IDReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{20}
}
func (m *IDReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IDReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IDReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IDReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IDReq.Merge(m, src)
}
func (m *IDReq) XXX_Size() int {
	return m.Size()
}
func (m *IDReq) XXX_DiscardUnknown() {
	xxx_messageInfo_IDReq.DiscardUnknown(m)
}

var xxx_messageInfo_IDReq proto.InternalMessageInfo

func (m *IDReq) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *IDReq) GetInclude() string {
	if m != nil {
		return m.Include
	}
	return ""
}

func (m *IDReq) GetAid() int64 {
	if m != nil {
		return m.Aid
	}
	return 0
}

type IDResp struct {
	ID                   int64    `protobuf:"varint,1,opt,name=ID,proto3" json:"id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IDResp) Reset()         { *m = IDResp{} }
func (m *IDResp) String() string { return proto.CompactTextString(m) }
func (*IDResp) ProtoMessage()    {}
func (*IDResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{21}
}
func (m *IDResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IDResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IDResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IDResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IDResp.Merge(m, src)
}
func (m *IDResp) XXX_Size() int {
	return m.Size()
}
func (m *IDResp) XXX_DiscardUnknown() {
	xxx_messageInfo_IDResp.DiscardUnknown(m)
}

var xxx_messageInfo_IDResp proto.InternalMessageInfo

func (m *IDResp) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

type TopicResp struct {
	ID              int64    `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Name            string   `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
	Avatar          string   `protobuf:"bytes,3,opt,name=Avatar,proto3" json:"Avatar,omitempty"`
	Bg              string   `protobuf:"bytes,4,opt,name=Bg,proto3" json:"Bg,omitempty"`
	Introduction    string   `protobuf:"bytes,5,opt,name=Introduction,proto3" json:"Introduction,omitempty"`
	AllowDiscuss    bool     `protobuf:"varint,6,opt,name=AllowDiscuss,proto3" json:"AllowDiscuss,omitempty"`
	AllowChat       bool     `protobuf:"varint,7,opt,name=AllowChat,proto3" json:"AllowChat,omitempty"`
	IsPrivate       bool     `protobuf:"varint,8,opt,name=IsPrivate,proto3" json:"IsPrivate,omitempty"`
	ViewPermission  string   `protobuf:"bytes,9,opt,name=ViewPermission,proto3" json:"ViewPermission,omitempty"`
	EditPermission  string   `protobuf:"bytes,10,opt,name=EditPermission,proto3" json:"EditPermission,omitempty"`
	JoinPermission  string   `protobuf:"bytes,11,opt,name=JoinPermission,proto3" json:"JoinPermission,omitempty"`
	CatalogViewType string   `protobuf:"bytes,12,opt,name=CatalogViewType,proto3" json:"CatalogViewType,omitempty"`
	TopicHome       string   `protobuf:"bytes,13,opt,name=TopicHome,proto3" json:"TopicHome,omitempty"`
	Creator         *Creator `protobuf:"bytes,14,opt,name=Creator,proto3" json:"Creator,omitempty"`
	// unix timestamp
	CreatedAt int64 `protobuf:"varint,15,opt,name=CreatedAt,proto3" json:"CreatedAt,omitempty"`
	// unix timestamp
	UpdatedAt            int64                   `protobuf:"varint,16,opt,name=UpdatedAt,proto3" json:"UpdatedAt,omitempty"`
	MuteNotification     bool                    `protobuf:"varint,18,opt,name=MuteNotification,proto3" json:"MuteNotification,omitempty"`
	Important            bool                    `protobuf:"varint,19,opt,name=Important,proto3" json:"Important,omitempty"`
	Stat                 *TopicStat              `protobuf:"bytes,20,opt,name=Stat,proto3" json:"Stat,omitempty"`
	HasCatalogTaxonomy   bool                    `protobuf:"varint,21,opt,name=HasCatalogTaxonomy,proto3" json:"HasCatalogTaxonomy,omitempty"`
	Members              []*TopicMemberInfo      `protobuf:"bytes,22,rep,name=Members,proto3" json:"Members,omitempty"`
	Catalogs             []*TopicRootCatalogInfo `protobuf:"bytes,24,rep,name=Catalogs,proto3" json:"Catalogs,omitempty"`
	DiscussCategories    []*DiscussCategoryInfo  `protobuf:"bytes,25,rep,name=DiscussCategories,proto3" json:"DiscussCategories,omitempty"`
	AuthTopics           []*AuthTopicInfo        `protobuf:"bytes,26,rep,name=AuthTopics,proto3" json:"AuthTopics,omitempty"`
	TopicMeta            *TopicMetaInfo          `protobuf:"bytes,27,opt,name=TopicMeta,proto3" json:"TopicMeta,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *TopicResp) Reset()         { *m = TopicResp{} }
func (m *TopicResp) String() string { return proto.CompactTextString(m) }
func (*TopicResp) ProtoMessage()    {}
func (*TopicResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{22}
}
func (m *TopicResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TopicResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TopicResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TopicResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TopicResp.Merge(m, src)
}
func (m *TopicResp) XXX_Size() int {
	return m.Size()
}
func (m *TopicResp) XXX_DiscardUnknown() {
	xxx_messageInfo_TopicResp.DiscardUnknown(m)
}

var xxx_messageInfo_TopicResp proto.InternalMessageInfo

func (m *TopicResp) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *TopicResp) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TopicResp) GetAvatar() string {
	if m != nil {
		return m.Avatar
	}
	return ""
}

func (m *TopicResp) GetBg() string {
	if m != nil {
		return m.Bg
	}
	return ""
}

func (m *TopicResp) GetIntroduction() string {
	if m != nil {
		return m.Introduction
	}
	return ""
}

func (m *TopicResp) GetAllowDiscuss() bool {
	if m != nil {
		return m.AllowDiscuss
	}
	return false
}

func (m *TopicResp) GetAllowChat() bool {
	if m != nil {
		return m.AllowChat
	}
	return false
}

func (m *TopicResp) GetIsPrivate() bool {
	if m != nil {
		return m.IsPrivate
	}
	return false
}

func (m *TopicResp) GetViewPermission() string {
	if m != nil {
		return m.ViewPermission
	}
	return ""
}

func (m *TopicResp) GetEditPermission() string {
	if m != nil {
		return m.EditPermission
	}
	return ""
}

func (m *TopicResp) GetJoinPermission() string {
	if m != nil {
		return m.JoinPermission
	}
	return ""
}

func (m *TopicResp) GetCatalogViewType() string {
	if m != nil {
		return m.CatalogViewType
	}
	return ""
}

func (m *TopicResp) GetTopicHome() string {
	if m != nil {
		return m.TopicHome
	}
	return ""
}

func (m *TopicResp) GetCreator() *Creator {
	if m != nil {
		return m.Creator
	}
	return nil
}

func (m *TopicResp) GetCreatedAt() int64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

func (m *TopicResp) GetUpdatedAt() int64 {
	if m != nil {
		return m.UpdatedAt
	}
	return 0
}

func (m *TopicResp) GetMuteNotification() bool {
	if m != nil {
		return m.MuteNotification
	}
	return false
}

func (m *TopicResp) GetImportant() bool {
	if m != nil {
		return m.Important
	}
	return false
}

func (m *TopicResp) GetStat() *TopicStat {
	if m != nil {
		return m.Stat
	}
	return nil
}

func (m *TopicResp) GetHasCatalogTaxonomy() bool {
	if m != nil {
		return m.HasCatalogTaxonomy
	}
	return false
}

func (m *TopicResp) GetMembers() []*TopicMemberInfo {
	if m != nil {
		return m.Members
	}
	return nil
}

func (m *TopicResp) GetCatalogs() []*TopicRootCatalogInfo {
	if m != nil {
		return m.Catalogs
	}
	return nil
}

func (m *TopicResp) GetDiscussCategories() []*DiscussCategoryInfo {
	if m != nil {
		return m.DiscussCategories
	}
	return nil
}

func (m *TopicResp) GetAuthTopics() []*AuthTopicInfo {
	if m != nil {
		return m.AuthTopics
	}
	return nil
}

func (m *TopicResp) GetTopicMeta() *TopicMetaInfo {
	if m != nil {
		return m.TopicMeta
	}
	return nil
}

type TopicMemberInfo struct {
	AccountID            int64    `protobuf:"varint,1,opt,name=AccountID,proto3" json:"AccountID,omitempty"`
	Role                 string   `protobuf:"bytes,2,opt,name=Role,proto3" json:"Role,omitempty"`
	Avatar               string   `protobuf:"bytes,3,opt,name=Avatar,proto3" json:"Avatar,omitempty"`
	UserName             string   `protobuf:"bytes,4,opt,name=UserName,proto3" json:"UserName,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TopicMemberInfo) Reset()         { *m = TopicMemberInfo{} }
func (m *TopicMemberInfo) String() string { return proto.CompactTextString(m) }
func (*TopicMemberInfo) ProtoMessage()    {}
func (*TopicMemberInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{23}
}
func (m *TopicMemberInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TopicMemberInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TopicMemberInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TopicMemberInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TopicMemberInfo.Merge(m, src)
}
func (m *TopicMemberInfo) XXX_Size() int {
	return m.Size()
}
func (m *TopicMemberInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TopicMemberInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TopicMemberInfo proto.InternalMessageInfo

func (m *TopicMemberInfo) GetAccountID() int64 {
	if m != nil {
		return m.AccountID
	}
	return 0
}

func (m *TopicMemberInfo) GetRole() string {
	if m != nil {
		return m.Role
	}
	return ""
}

func (m *TopicMemberInfo) GetAvatar() string {
	if m != nil {
		return m.Avatar
	}
	return ""
}

func (m *TopicMemberInfo) GetUserName() string {
	if m != nil {
		return m.UserName
	}
	return ""
}

type AuthTopicInfo struct {
	ToTopicID            int64    `protobuf:"varint,1,opt,name=ToTopicID,proto3" json:"ToTopicID,omitempty"`
	EditPermission       string   `protobuf:"bytes,2,opt,name=EditPermission,proto3" json:"EditPermission,omitempty"`
	Permission           string   `protobuf:"bytes,3,opt,name=Permission,proto3" json:"Permission,omitempty"`
	MemberCount          int32    `protobuf:"varint,4,opt,name=MemberCount,proto3" json:"MemberCount,omitempty"`
	Avatar               string   `protobuf:"bytes,5,opt,name=Avatar,proto3" json:"Avatar,omitempty"`
	Name                 string   `protobuf:"bytes,6,opt,name=Name,proto3" json:"Name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AuthTopicInfo) Reset()         { *m = AuthTopicInfo{} }
func (m *AuthTopicInfo) String() string { return proto.CompactTextString(m) }
func (*AuthTopicInfo) ProtoMessage()    {}
func (*AuthTopicInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{24}
}
func (m *AuthTopicInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthTopicInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthTopicInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthTopicInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthTopicInfo.Merge(m, src)
}
func (m *AuthTopicInfo) XXX_Size() int {
	return m.Size()
}
func (m *AuthTopicInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthTopicInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AuthTopicInfo proto.InternalMessageInfo

func (m *AuthTopicInfo) GetToTopicID() int64 {
	if m != nil {
		return m.ToTopicID
	}
	return 0
}

func (m *AuthTopicInfo) GetEditPermission() string {
	if m != nil {
		return m.EditPermission
	}
	return ""
}

func (m *AuthTopicInfo) GetPermission() string {
	if m != nil {
		return m.Permission
	}
	return ""
}

func (m *AuthTopicInfo) GetMemberCount() int32 {
	if m != nil {
		return m.MemberCount
	}
	return 0
}

func (m *AuthTopicInfo) GetAvatar() string {
	if m != nil {
		return m.Avatar
	}
	return ""
}

func (m *AuthTopicInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type DiscussCategoryInfo struct {
	ID                   int64    `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	TopicID              int64    `protobuf:"varint,2,opt,name=TopicID,proto3" json:"TopicID,omitempty"`
	Name                 string   `protobuf:"bytes,3,opt,name=Name,proto3" json:"Name,omitempty"`
	Seq                  int32    `protobuf:"varint,4,opt,name=Seq,proto3" json:"Seq,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DiscussCategoryInfo) Reset()         { *m = DiscussCategoryInfo{} }
func (m *DiscussCategoryInfo) String() string { return proto.CompactTextString(m) }
func (*DiscussCategoryInfo) ProtoMessage()    {}
func (*DiscussCategoryInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{25}
}
func (m *DiscussCategoryInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DiscussCategoryInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DiscussCategoryInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DiscussCategoryInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DiscussCategoryInfo.Merge(m, src)
}
func (m *DiscussCategoryInfo) XXX_Size() int {
	return m.Size()
}
func (m *DiscussCategoryInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DiscussCategoryInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DiscussCategoryInfo proto.InternalMessageInfo

func (m *DiscussCategoryInfo) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *DiscussCategoryInfo) GetTopicID() int64 {
	if m != nil {
		return m.TopicID
	}
	return 0
}

func (m *DiscussCategoryInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DiscussCategoryInfo) GetSeq() int32 {
	if m != nil {
		return m.Seq
	}
	return 0
}

type ArgChangeOwner struct {
	TopicID              int64    `protobuf:"varint,1,opt,name=TopicID,proto3" json:"TopicID,omitempty"`
	ToAccountID          int64    `protobuf:"varint,2,opt,name=ToAccountID,proto3" json:"ToAccountID,omitempty"`
	Aid                  int64    `protobuf:"varint,3,opt,name=Aid,proto3" json:"Aid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ArgChangeOwner) Reset()         { *m = ArgChangeOwner{} }
func (m *ArgChangeOwner) String() string { return proto.CompactTextString(m) }
func (*ArgChangeOwner) ProtoMessage()    {}
func (*ArgChangeOwner) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{26}
}
func (m *ArgChangeOwner) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArgChangeOwner) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArgChangeOwner.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArgChangeOwner) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArgChangeOwner.Merge(m, src)
}
func (m *ArgChangeOwner) XXX_Size() int {
	return m.Size()
}
func (m *ArgChangeOwner) XXX_DiscardUnknown() {
	xxx_messageInfo_ArgChangeOwner.DiscardUnknown(m)
}

var xxx_messageInfo_ArgChangeOwner proto.InternalMessageInfo

func (m *ArgChangeOwner) GetTopicID() int64 {
	if m != nil {
		return m.TopicID
	}
	return 0
}

func (m *ArgChangeOwner) GetToAccountID() int64 {
	if m != nil {
		return m.ToAccountID
	}
	return 0
}

func (m *ArgChangeOwner) GetAid() int64 {
	if m != nil {
		return m.Aid
	}
	return 0
}

type ArgCreateTopic struct {
	Aid int64 `protobuf:"varint,1,opt,name=Aid,proto3" json:"Aid,omitempty"`
	// Types that are valid to be assigned to Avatar:
	//	*ArgCreateTopic_AvatarValue
	Avatar isArgCreateTopic_Avatar `protobuf_oneof:"Avatar"`
	// Types that are valid to be assigned to Bg:
	//	*ArgCreateTopic_BgValue
	Bg                   isArgCreateTopic_Bg `protobuf_oneof:"Bg"`
	Name                 string              `protobuf:"bytes,4,opt,name=Name,proto3" json:"Name,omitempty"`
	Introduction         string              `protobuf:"bytes,5,opt,name=Introduction,proto3" json:"Introduction,omitempty"`
	CatalogViewType      string              `protobuf:"bytes,6,opt,name=CatalogViewType,proto3" json:"CatalogViewType,omitempty"`
	AllowDiscuss         bool                `protobuf:"varint,7,opt,name=AllowDiscuss,proto3" json:"AllowDiscuss,omitempty"`
	AllowChat            bool                `protobuf:"varint,8,opt,name=AllowChat,proto3" json:"AllowChat,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *ArgCreateTopic) Reset()         { *m = ArgCreateTopic{} }
func (m *ArgCreateTopic) String() string { return proto.CompactTextString(m) }
func (*ArgCreateTopic) ProtoMessage()    {}
func (*ArgCreateTopic) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{27}
}
func (m *ArgCreateTopic) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArgCreateTopic) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArgCreateTopic.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArgCreateTopic) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArgCreateTopic.Merge(m, src)
}
func (m *ArgCreateTopic) XXX_Size() int {
	return m.Size()
}
func (m *ArgCreateTopic) XXX_DiscardUnknown() {
	xxx_messageInfo_ArgCreateTopic.DiscardUnknown(m)
}

var xxx_messageInfo_ArgCreateTopic proto.InternalMessageInfo

type isArgCreateTopic_Avatar interface {
	isArgCreateTopic_Avatar()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isArgCreateTopic_Bg interface {
	isArgCreateTopic_Bg()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ArgCreateTopic_AvatarValue struct {
	AvatarValue string `protobuf:"bytes,2,opt,name=AvatarValue,proto3,oneof" json:"AvatarValue,omitempty"`
}
type ArgCreateTopic_BgValue struct {
	BgValue string `protobuf:"bytes,3,opt,name=BgValue,proto3,oneof" json:"BgValue,omitempty"`
}

func (*ArgCreateTopic_AvatarValue) isArgCreateTopic_Avatar() {}
func (*ArgCreateTopic_BgValue) isArgCreateTopic_Bg()         {}

func (m *ArgCreateTopic) GetAvatar() isArgCreateTopic_Avatar {
	if m != nil {
		return m.Avatar
	}
	return nil
}
func (m *ArgCreateTopic) GetBg() isArgCreateTopic_Bg {
	if m != nil {
		return m.Bg
	}
	return nil
}

func (m *ArgCreateTopic) GetAid() int64 {
	if m != nil {
		return m.Aid
	}
	return 0
}

func (m *ArgCreateTopic) GetAvatarValue() string {
	if x, ok := m.GetAvatar().(*ArgCreateTopic_AvatarValue); ok {
		return x.AvatarValue
	}
	return ""
}

func (m *ArgCreateTopic) GetBgValue() string {
	if x, ok := m.GetBg().(*ArgCreateTopic_BgValue); ok {
		return x.BgValue
	}
	return ""
}

func (m *ArgCreateTopic) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ArgCreateTopic) GetIntroduction() string {
	if m != nil {
		return m.Introduction
	}
	return ""
}

func (m *ArgCreateTopic) GetCatalogViewType() string {
	if m != nil {
		return m.CatalogViewType
	}
	return ""
}

func (m *ArgCreateTopic) GetAllowDiscuss() bool {
	if m != nil {
		return m.AllowDiscuss
	}
	return false
}

func (m *ArgCreateTopic) GetAllowChat() bool {
	if m != nil {
		return m.AllowChat
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ArgCreateTopic) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ArgCreateTopic_AvatarValue)(nil),
		(*ArgCreateTopic_BgValue)(nil),
	}
}

type ArgUpdateTopic struct {
	ID int64 `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	// Types that are valid to be assigned to Avatar:
	//	*ArgUpdateTopic_AvatarValue
	Avatar isArgUpdateTopic_Avatar `protobuf_oneof:"Avatar"`
	// Types that are valid to be assigned to Bg:
	//	*ArgUpdateTopic_BgValue
	Bg isArgUpdateTopic_Bg `protobuf_oneof:"Bg"`
	// Types that are valid to be assigned to Name:
	//	*ArgUpdateTopic_NameValue
	Name isArgUpdateTopic_Name `protobuf_oneof:"Name"`
	// Types that are valid to be assigned to Introduction:
	//	*ArgUpdateTopic_IntroductionValue
	Introduction isArgUpdateTopic_Introduction `protobuf_oneof:"Introduction"`
	// Types that are valid to be assigned to CatalogViewType:
	//	*ArgUpdateTopic_CatalogViewTypeValue
	CatalogViewType isArgUpdateTopic_CatalogViewType `protobuf_oneof:"CatalogViewType"`
	// Types that are valid to be assigned to AllowChat:
	//	*ArgUpdateTopic_AllowChatValue
	AllowChat isArgUpdateTopic_AllowChat `protobuf_oneof:"AllowChat"`
	// Types that are valid to be assigned to AllowDiscuss:
	//	*ArgUpdateTopic_AllowDiscussValue
	AllowDiscuss isArgUpdateTopic_AllowDiscuss `protobuf_oneof:"AllowDiscuss"`
	// Types that are valid to be assigned to IsPrivate:
	//	*ArgUpdateTopic_IsPrivateValue
	IsPrivate isArgUpdateTopic_IsPrivate `protobuf_oneof:"IsPrivate"`
	// Types that are valid to be assigned to ViewPermission:
	//	*ArgUpdateTopic_ViewPermissionValue
	ViewPermission isArgUpdateTopic_ViewPermission `protobuf_oneof:"ViewPermission"`
	// Types that are valid to be assigned to EditPermission:
	//	*ArgUpdateTopic_EditPermissionValue
	EditPermission isArgUpdateTopic_EditPermission `protobuf_oneof:"EditPermission"`
	// Types that are valid to be assigned to JoinPermission:
	//	*ArgUpdateTopic_JoinPermissionValue
	JoinPermission isArgUpdateTopic_JoinPermission `protobuf_oneof:"JoinPermission"`
	// Types that are valid to be assigned to Important:
	//	*ArgUpdateTopic_ImportantValue
	Important isArgUpdateTopic_Important `protobuf_oneof:"Important"`
	// Types that are valid to be assigned to MuteNotification:
	//	*ArgUpdateTopic_MuteNotificationValue
	MuteNotification     isArgUpdateTopic_MuteNotification `protobuf_oneof:"MuteNotification"`
	Aid                  int64                             `protobuf:"varint,15,opt,name=Aid,proto3" json:"Aid,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                          `json:"-"`
	XXX_unrecognized     []byte                            `json:"-"`
	XXX_sizecache        int32                             `json:"-"`
}

func (m *ArgUpdateTopic) Reset()         { *m = ArgUpdateTopic{} }
func (m *ArgUpdateTopic) String() string { return proto.CompactTextString(m) }
func (*ArgUpdateTopic) ProtoMessage()    {}
func (*ArgUpdateTopic) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{28}
}
func (m *ArgUpdateTopic) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArgUpdateTopic) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArgUpdateTopic.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArgUpdateTopic) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArgUpdateTopic.Merge(m, src)
}
func (m *ArgUpdateTopic) XXX_Size() int {
	return m.Size()
}
func (m *ArgUpdateTopic) XXX_DiscardUnknown() {
	xxx_messageInfo_ArgUpdateTopic.DiscardUnknown(m)
}

var xxx_messageInfo_ArgUpdateTopic proto.InternalMessageInfo

type isArgUpdateTopic_Avatar interface {
	isArgUpdateTopic_Avatar()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isArgUpdateTopic_Bg interface {
	isArgUpdateTopic_Bg()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isArgUpdateTopic_Name interface {
	isArgUpdateTopic_Name()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isArgUpdateTopic_Introduction interface {
	isArgUpdateTopic_Introduction()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isArgUpdateTopic_CatalogViewType interface {
	isArgUpdateTopic_CatalogViewType()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isArgUpdateTopic_AllowChat interface {
	isArgUpdateTopic_AllowChat()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isArgUpdateTopic_AllowDiscuss interface {
	isArgUpdateTopic_AllowDiscuss()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isArgUpdateTopic_IsPrivate interface {
	isArgUpdateTopic_IsPrivate()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isArgUpdateTopic_ViewPermission interface {
	isArgUpdateTopic_ViewPermission()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isArgUpdateTopic_EditPermission interface {
	isArgUpdateTopic_EditPermission()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isArgUpdateTopic_JoinPermission interface {
	isArgUpdateTopic_JoinPermission()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isArgUpdateTopic_Important interface {
	isArgUpdateTopic_Important()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isArgUpdateTopic_MuteNotification interface {
	isArgUpdateTopic_MuteNotification()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ArgUpdateTopic_AvatarValue struct {
	AvatarValue string `protobuf:"bytes,2,opt,name=AvatarValue,proto3,oneof" json:"AvatarValue,omitempty"`
}
type ArgUpdateTopic_BgValue struct {
	BgValue string `protobuf:"bytes,3,opt,name=BgValue,proto3,oneof" json:"BgValue,omitempty"`
}
type ArgUpdateTopic_NameValue struct {
	NameValue string `protobuf:"bytes,4,opt,name=NameValue,proto3,oneof" json:"NameValue,omitempty"`
}
type ArgUpdateTopic_IntroductionValue struct {
	IntroductionValue string `protobuf:"bytes,5,opt,name=IntroductionValue,proto3,oneof" json:"IntroductionValue,omitempty"`
}
type ArgUpdateTopic_CatalogViewTypeValue struct {
	CatalogViewTypeValue string `protobuf:"bytes,6,opt,name=CatalogViewTypeValue,proto3,oneof" json:"CatalogViewTypeValue,omitempty"`
}
type ArgUpdateTopic_AllowChatValue struct {
	AllowChatValue bool `protobuf:"varint,7,opt,name=AllowChatValue,proto3,oneof" json:"AllowChatValue,omitempty"`
}
type ArgUpdateTopic_AllowDiscussValue struct {
	AllowDiscussValue bool `protobuf:"varint,8,opt,name=AllowDiscussValue,proto3,oneof" json:"AllowDiscussValue,omitempty"`
}
type ArgUpdateTopic_IsPrivateValue struct {
	IsPrivateValue bool `protobuf:"varint,9,opt,name=IsPrivateValue,proto3,oneof" json:"IsPrivateValue,omitempty"`
}
type ArgUpdateTopic_ViewPermissionValue struct {
	ViewPermissionValue string `protobuf:"bytes,10,opt,name=ViewPermissionValue,proto3,oneof" json:"ViewPermissionValue,omitempty"`
}
type ArgUpdateTopic_EditPermissionValue struct {
	EditPermissionValue string `protobuf:"bytes,11,opt,name=EditPermissionValue,proto3,oneof" json:"EditPermissionValue,omitempty"`
}
type ArgUpdateTopic_JoinPermissionValue struct {
	JoinPermissionValue string `protobuf:"bytes,12,opt,name=JoinPermissionValue,proto3,oneof" json:"JoinPermissionValue,omitempty"`
}
type ArgUpdateTopic_ImportantValue struct {
	ImportantValue bool `protobuf:"varint,13,opt,name=ImportantValue,proto3,oneof" json:"ImportantValue,omitempty"`
}
type ArgUpdateTopic_MuteNotificationValue struct {
	MuteNotificationValue bool `protobuf:"varint,14,opt,name=MuteNotificationValue,proto3,oneof" json:"MuteNotificationValue,omitempty"`
}

func (*ArgUpdateTopic_AvatarValue) isArgUpdateTopic_Avatar()                     {}
func (*ArgUpdateTopic_BgValue) isArgUpdateTopic_Bg()                             {}
func (*ArgUpdateTopic_NameValue) isArgUpdateTopic_Name()                         {}
func (*ArgUpdateTopic_IntroductionValue) isArgUpdateTopic_Introduction()         {}
func (*ArgUpdateTopic_CatalogViewTypeValue) isArgUpdateTopic_CatalogViewType()   {}
func (*ArgUpdateTopic_AllowChatValue) isArgUpdateTopic_AllowChat()               {}
func (*ArgUpdateTopic_AllowDiscussValue) isArgUpdateTopic_AllowDiscuss()         {}
func (*ArgUpdateTopic_IsPrivateValue) isArgUpdateTopic_IsPrivate()               {}
func (*ArgUpdateTopic_ViewPermissionValue) isArgUpdateTopic_ViewPermission()     {}
func (*ArgUpdateTopic_EditPermissionValue) isArgUpdateTopic_EditPermission()     {}
func (*ArgUpdateTopic_JoinPermissionValue) isArgUpdateTopic_JoinPermission()     {}
func (*ArgUpdateTopic_ImportantValue) isArgUpdateTopic_Important()               {}
func (*ArgUpdateTopic_MuteNotificationValue) isArgUpdateTopic_MuteNotification() {}

func (m *ArgUpdateTopic) GetAvatar() isArgUpdateTopic_Avatar {
	if m != nil {
		return m.Avatar
	}
	return nil
}
func (m *ArgUpdateTopic) GetBg() isArgUpdateTopic_Bg {
	if m != nil {
		return m.Bg
	}
	return nil
}
func (m *ArgUpdateTopic) GetName() isArgUpdateTopic_Name {
	if m != nil {
		return m.Name
	}
	return nil
}
func (m *ArgUpdateTopic) GetIntroduction() isArgUpdateTopic_Introduction {
	if m != nil {
		return m.Introduction
	}
	return nil
}
func (m *ArgUpdateTopic) GetCatalogViewType() isArgUpdateTopic_CatalogViewType {
	if m != nil {
		return m.CatalogViewType
	}
	return nil
}
func (m *ArgUpdateTopic) GetAllowChat() isArgUpdateTopic_AllowChat {
	if m != nil {
		return m.AllowChat
	}
	return nil
}
func (m *ArgUpdateTopic) GetAllowDiscuss() isArgUpdateTopic_AllowDiscuss {
	if m != nil {
		return m.AllowDiscuss
	}
	return nil
}
func (m *ArgUpdateTopic) GetIsPrivate() isArgUpdateTopic_IsPrivate {
	if m != nil {
		return m.IsPrivate
	}
	return nil
}
func (m *ArgUpdateTopic) GetViewPermission() isArgUpdateTopic_ViewPermission {
	if m != nil {
		return m.ViewPermission
	}
	return nil
}
func (m *ArgUpdateTopic) GetEditPermission() isArgUpdateTopic_EditPermission {
	if m != nil {
		return m.EditPermission
	}
	return nil
}
func (m *ArgUpdateTopic) GetJoinPermission() isArgUpdateTopic_JoinPermission {
	if m != nil {
		return m.JoinPermission
	}
	return nil
}
func (m *ArgUpdateTopic) GetImportant() isArgUpdateTopic_Important {
	if m != nil {
		return m.Important
	}
	return nil
}
func (m *ArgUpdateTopic) GetMuteNotification() isArgUpdateTopic_MuteNotification {
	if m != nil {
		return m.MuteNotification
	}
	return nil
}

func (m *ArgUpdateTopic) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *ArgUpdateTopic) GetAvatarValue() string {
	if x, ok := m.GetAvatar().(*ArgUpdateTopic_AvatarValue); ok {
		return x.AvatarValue
	}
	return ""
}

func (m *ArgUpdateTopic) GetBgValue() string {
	if x, ok := m.GetBg().(*ArgUpdateTopic_BgValue); ok {
		return x.BgValue
	}
	return ""
}

func (m *ArgUpdateTopic) GetNameValue() string {
	if x, ok := m.GetName().(*ArgUpdateTopic_NameValue); ok {
		return x.NameValue
	}
	return ""
}

func (m *ArgUpdateTopic) GetIntroductionValue() string {
	if x, ok := m.GetIntroduction().(*ArgUpdateTopic_IntroductionValue); ok {
		return x.IntroductionValue
	}
	return ""
}

func (m *ArgUpdateTopic) GetCatalogViewTypeValue() string {
	if x, ok := m.GetCatalogViewType().(*ArgUpdateTopic_CatalogViewTypeValue); ok {
		return x.CatalogViewTypeValue
	}
	return ""
}

func (m *ArgUpdateTopic) GetAllowChatValue() bool {
	if x, ok := m.GetAllowChat().(*ArgUpdateTopic_AllowChatValue); ok {
		return x.AllowChatValue
	}
	return false
}

func (m *ArgUpdateTopic) GetAllowDiscussValue() bool {
	if x, ok := m.GetAllowDiscuss().(*ArgUpdateTopic_AllowDiscussValue); ok {
		return x.AllowDiscussValue
	}
	return false
}

func (m *ArgUpdateTopic) GetIsPrivateValue() bool {
	if x, ok := m.GetIsPrivate().(*ArgUpdateTopic_IsPrivateValue); ok {
		return x.IsPrivateValue
	}
	return false
}

func (m *ArgUpdateTopic) GetViewPermissionValue() string {
	if x, ok := m.GetViewPermission().(*ArgUpdateTopic_ViewPermissionValue); ok {
		return x.ViewPermissionValue
	}
	return ""
}

func (m *ArgUpdateTopic) GetEditPermissionValue() string {
	if x, ok := m.GetEditPermission().(*ArgUpdateTopic_EditPermissionValue); ok {
		return x.EditPermissionValue
	}
	return ""
}

func (m *ArgUpdateTopic) GetJoinPermissionValue() string {
	if x, ok := m.GetJoinPermission().(*ArgUpdateTopic_JoinPermissionValue); ok {
		return x.JoinPermissionValue
	}
	return ""
}

func (m *ArgUpdateTopic) GetImportantValue() bool {
	if x, ok := m.GetImportant().(*ArgUpdateTopic_ImportantValue); ok {
		return x.ImportantValue
	}
	return false
}

func (m *ArgUpdateTopic) GetMuteNotificationValue() bool {
	if x, ok := m.GetMuteNotification().(*ArgUpdateTopic_MuteNotificationValue); ok {
		return x.MuteNotificationValue
	}
	return false
}

func (m *ArgUpdateTopic) GetAid() int64 {
	if m != nil {
		return m.Aid
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ArgUpdateTopic) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ArgUpdateTopic_AvatarValue)(nil),
		(*ArgUpdateTopic_BgValue)(nil),
		(*ArgUpdateTopic_NameValue)(nil),
		(*ArgUpdateTopic_IntroductionValue)(nil),
		(*ArgUpdateTopic_CatalogViewTypeValue)(nil),
		(*ArgUpdateTopic_AllowChatValue)(nil),
		(*ArgUpdateTopic_AllowDiscussValue)(nil),
		(*ArgUpdateTopic_IsPrivateValue)(nil),
		(*ArgUpdateTopic_ViewPermissionValue)(nil),
		(*ArgUpdateTopic_EditPermissionValue)(nil),
		(*ArgUpdateTopic_JoinPermissionValue)(nil),
		(*ArgUpdateTopic_ImportantValue)(nil),
		(*ArgUpdateTopic_MuteNotificationValue)(nil),
	}
}

type TopicMembersPagedResp struct {
	Count                int32              `protobuf:"varint,1,opt,name=Count,proto3" json:"Count,omitempty"`
	PageSize             int32              `protobuf:"varint,2,opt,name=PageSize,proto3" json:"PageSize,omitempty"`
	Data                 []*TopicMemberInfo `protobuf:"bytes,3,rep,name=Data,proto3" json:"Data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *TopicMembersPagedResp) Reset()         { *m = TopicMembersPagedResp{} }
func (m *TopicMembersPagedResp) String() string { return proto.CompactTextString(m) }
func (*TopicMembersPagedResp) ProtoMessage()    {}
func (*TopicMembersPagedResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{29}
}
func (m *TopicMembersPagedResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TopicMembersPagedResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TopicMembersPagedResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TopicMembersPagedResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TopicMembersPagedResp.Merge(m, src)
}
func (m *TopicMembersPagedResp) XXX_Size() int {
	return m.Size()
}
func (m *TopicMembersPagedResp) XXX_DiscardUnknown() {
	xxx_messageInfo_TopicMembersPagedResp.DiscardUnknown(m)
}

var xxx_messageInfo_TopicMembersPagedResp proto.InternalMessageInfo

func (m *TopicMembersPagedResp) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *TopicMembersPagedResp) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *TopicMembersPagedResp) GetData() []*TopicMemberInfo {
	if m != nil {
		return m.Data
	}
	return nil
}

type ArgBatchSavedTopicMember struct {
	TopicID              int64             `protobuf:"varint,1,opt,name=TopicID,proto3" json:"TopicID,omitempty"`
	Members              []*ArgTopicMember `protobuf:"bytes,2,rep,name=Members,proto3" json:"Members,omitempty"`
	Aid                  int64             `protobuf:"varint,3,opt,name=Aid,proto3" json:"Aid,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ArgBatchSavedTopicMember) Reset()         { *m = ArgBatchSavedTopicMember{} }
func (m *ArgBatchSavedTopicMember) String() string { return proto.CompactTextString(m) }
func (*ArgBatchSavedTopicMember) ProtoMessage()    {}
func (*ArgBatchSavedTopicMember) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{30}
}
func (m *ArgBatchSavedTopicMember) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArgBatchSavedTopicMember) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArgBatchSavedTopicMember.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArgBatchSavedTopicMember) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArgBatchSavedTopicMember.Merge(m, src)
}
func (m *ArgBatchSavedTopicMember) XXX_Size() int {
	return m.Size()
}
func (m *ArgBatchSavedTopicMember) XXX_DiscardUnknown() {
	xxx_messageInfo_ArgBatchSavedTopicMember.DiscardUnknown(m)
}

var xxx_messageInfo_ArgBatchSavedTopicMember proto.InternalMessageInfo

func (m *ArgBatchSavedTopicMember) GetTopicID() int64 {
	if m != nil {
		return m.TopicID
	}
	return 0
}

func (m *ArgBatchSavedTopicMember) GetMembers() []*ArgTopicMember {
	if m != nil {
		return m.Members
	}
	return nil
}

func (m *ArgBatchSavedTopicMember) GetAid() int64 {
	if m != nil {
		return m.Aid
	}
	return 0
}

type ArgTopicMember struct {
	AccountID            int64    `protobuf:"varint,1,opt,name=AccountID,proto3" json:"AccountID,omitempty"`
	Role                 string   `protobuf:"bytes,2,opt,name=Role,proto3" json:"Role,omitempty"`
	Opt                  string   `protobuf:"bytes,3,opt,name=Opt,proto3" json:"Opt,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ArgTopicMember) Reset()         { *m = ArgTopicMember{} }
func (m *ArgTopicMember) String() string { return proto.CompactTextString(m) }
func (*ArgTopicMember) ProtoMessage()    {}
func (*ArgTopicMember) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{31}
}
func (m *ArgTopicMember) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArgTopicMember) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArgTopicMember.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArgTopicMember) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArgTopicMember.Merge(m, src)
}
func (m *ArgTopicMember) XXX_Size() int {
	return m.Size()
}
func (m *ArgTopicMember) XXX_DiscardUnknown() {
	xxx_messageInfo_ArgTopicMember.DiscardUnknown(m)
}

var xxx_messageInfo_ArgTopicMember proto.InternalMessageInfo

func (m *ArgTopicMember) GetAccountID() int64 {
	if m != nil {
		return m.AccountID
	}
	return 0
}

func (m *ArgTopicMember) GetRole() string {
	if m != nil {
		return m.Role
	}
	return ""
}

func (m *ArgTopicMember) GetOpt() string {
	if m != nil {
		return m.Opt
	}
	return ""
}

type ArgTopicCatalog struct {
	// Types that are valid to be assigned to ID:
	//	*ArgTopicCatalog_IDValue
	ID                   isArgTopicCatalog_ID `protobuf_oneof:"ID"`
	Name                 string               `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
	Seq                  int32                `protobuf:"varint,3,opt,name=Seq,proto3" json:"Seq,omitempty"`
	Type                 string               `protobuf:"bytes,4,opt,name=Type,proto3" json:"Type,omitempty"`
	RefID                int64                `protobuf:"varint,5,opt,name=RefID,proto3" json:"RefID,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *ArgTopicCatalog) Reset()         { *m = ArgTopicCatalog{} }
func (m *ArgTopicCatalog) String() string { return proto.CompactTextString(m) }
func (*ArgTopicCatalog) ProtoMessage()    {}
func (*ArgTopicCatalog) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{32}
}
func (m *ArgTopicCatalog) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArgTopicCatalog) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArgTopicCatalog.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArgTopicCatalog) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArgTopicCatalog.Merge(m, src)
}
func (m *ArgTopicCatalog) XXX_Size() int {
	return m.Size()
}
func (m *ArgTopicCatalog) XXX_DiscardUnknown() {
	xxx_messageInfo_ArgTopicCatalog.DiscardUnknown(m)
}

var xxx_messageInfo_ArgTopicCatalog proto.InternalMessageInfo

type isArgTopicCatalog_ID interface {
	isArgTopicCatalog_ID()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ArgTopicCatalog_IDValue struct {
	IDValue int64 `protobuf:"varint,1,opt,name=IDValue,proto3,oneof" json:"IDValue,omitempty"`
}

func (*ArgTopicCatalog_IDValue) isArgTopicCatalog_ID() {}

func (m *ArgTopicCatalog) GetID() isArgTopicCatalog_ID {
	if m != nil {
		return m.ID
	}
	return nil
}

func (m *ArgTopicCatalog) GetIDValue() int64 {
	if x, ok := m.GetID().(*ArgTopicCatalog_IDValue); ok {
		return x.IDValue
	}
	return 0
}

func (m *ArgTopicCatalog) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ArgTopicCatalog) GetSeq() int32 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *ArgTopicCatalog) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *ArgTopicCatalog) GetRefID() int64 {
	if m != nil {
		return m.RefID
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ArgTopicCatalog) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ArgTopicCatalog_IDValue)(nil),
	}
}

type ArgCanEditTopicsReq struct {
	Pn                   int32    `protobuf:"varint,1,opt,name=Pn,proto3" json:"Pn,omitempty"`
	Ps                   int32    `protobuf:"varint,2,opt,name=Ps,proto3" json:"Ps,omitempty"`
	Query                string   `protobuf:"bytes,3,opt,name=Query,proto3" json:"Query,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ArgCanEditTopicsReq) Reset()         { *m = ArgCanEditTopicsReq{} }
func (m *ArgCanEditTopicsReq) String() string { return proto.CompactTextString(m) }
func (*ArgCanEditTopicsReq) ProtoMessage()    {}
func (*ArgCanEditTopicsReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{33}
}
func (m *ArgCanEditTopicsReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArgCanEditTopicsReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArgCanEditTopicsReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArgCanEditTopicsReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArgCanEditTopicsReq.Merge(m, src)
}
func (m *ArgCanEditTopicsReq) XXX_Size() int {
	return m.Size()
}
func (m *ArgCanEditTopicsReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ArgCanEditTopicsReq.DiscardUnknown(m)
}

var xxx_messageInfo_ArgCanEditTopicsReq proto.InternalMessageInfo

func (m *ArgCanEditTopicsReq) GetPn() int32 {
	if m != nil {
		return m.Pn
	}
	return 0
}

func (m *ArgCanEditTopicsReq) GetPs() int32 {
	if m != nil {
		return m.Ps
	}
	return 0
}

func (m *ArgCanEditTopicsReq) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

type CanEditTopicsResp struct {
	Items                []*CanEditTopicItem `protobuf:"bytes,1,rep,name=Items,proto3" json:"Items,omitempty"`
	Paging               *Paging             `protobuf:"bytes,2,opt,name=Paging,proto3" json:"Paging,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *CanEditTopicsResp) Reset()         { *m = CanEditTopicsResp{} }
func (m *CanEditTopicsResp) String() string { return proto.CompactTextString(m) }
func (*CanEditTopicsResp) ProtoMessage()    {}
func (*CanEditTopicsResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{34}
}
func (m *CanEditTopicsResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CanEditTopicsResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CanEditTopicsResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CanEditTopicsResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CanEditTopicsResp.Merge(m, src)
}
func (m *CanEditTopicsResp) XXX_Size() int {
	return m.Size()
}
func (m *CanEditTopicsResp) XXX_DiscardUnknown() {
	xxx_messageInfo_CanEditTopicsResp.DiscardUnknown(m)
}

var xxx_messageInfo_CanEditTopicsResp proto.InternalMessageInfo

func (m *CanEditTopicsResp) GetItems() []*CanEditTopicItem {
	if m != nil {
		return m.Items
	}
	return nil
}

func (m *CanEditTopicsResp) GetPaging() *Paging {
	if m != nil {
		return m.Paging
	}
	return nil
}

type CanEditTopicItem struct {
	ID                   int64    `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Name                 string   `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
	Avatar               string   `protobuf:"bytes,3,opt,name=Avatar,proto3" json:"Avatar,omitempty"`
	Introduction         string   `protobuf:"bytes,5,opt,name=Introduction,proto3" json:"Introduction,omitempty"`
	MemberCount          int32    `protobuf:"varint,6,opt,name=MemberCount,proto3" json:"MemberCount,omitempty"`
	ArticleCount         int32    `protobuf:"varint,7,opt,name=ArticleCount,proto3" json:"ArticleCount,omitempty"`
	DiscussionCount      int32    `protobuf:"varint,8,opt,name=DiscussionCount,proto3" json:"DiscussionCount,omitempty"`
	EditPermission       string   `protobuf:"bytes,9,opt,name=EditPermission,proto3" json:"EditPermission,omitempty"`
	HasCatalogTaxonomy   bool     `protobuf:"varint,10,opt,name=HasCatalogTaxonomy,proto3" json:"HasCatalogTaxonomy,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CanEditTopicItem) Reset()         { *m = CanEditTopicItem{} }
func (m *CanEditTopicItem) String() string { return proto.CompactTextString(m) }
func (*CanEditTopicItem) ProtoMessage()    {}
func (*CanEditTopicItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{35}
}
func (m *CanEditTopicItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CanEditTopicItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CanEditTopicItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CanEditTopicItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CanEditTopicItem.Merge(m, src)
}
func (m *CanEditTopicItem) XXX_Size() int {
	return m.Size()
}
func (m *CanEditTopicItem) XXX_DiscardUnknown() {
	xxx_messageInfo_CanEditTopicItem.DiscardUnknown(m)
}

var xxx_messageInfo_CanEditTopicItem proto.InternalMessageInfo

func (m *CanEditTopicItem) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *CanEditTopicItem) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CanEditTopicItem) GetAvatar() string {
	if m != nil {
		return m.Avatar
	}
	return ""
}

func (m *CanEditTopicItem) GetIntroduction() string {
	if m != nil {
		return m.Introduction
	}
	return ""
}

func (m *CanEditTopicItem) GetMemberCount() int32 {
	if m != nil {
		return m.MemberCount
	}
	return 0
}

func (m *CanEditTopicItem) GetArticleCount() int32 {
	if m != nil {
		return m.ArticleCount
	}
	return 0
}

func (m *CanEditTopicItem) GetDiscussionCount() int32 {
	if m != nil {
		return m.DiscussionCount
	}
	return 0
}

func (m *CanEditTopicItem) GetEditPermission() string {
	if m != nil {
		return m.EditPermission
	}
	return ""
}

func (m *CanEditTopicItem) GetHasCatalogTaxonomy() bool {
	if m != nil {
		return m.HasCatalogTaxonomy
	}
	return false
}

type Paging struct {
	Total                int32    `protobuf:"varint,1,opt,name=Total,proto3" json:"Total,omitempty"`
	IsEnd                bool     `protobuf:"varint,2,opt,name=IsEnd,proto3" json:"IsEnd,omitempty"`
	Next                 string   `protobuf:"bytes,3,opt,name=Next,proto3" json:"Next,omitempty"`
	Prev                 string   `protobuf:"bytes,4,opt,name=Prev,proto3" json:"Prev,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Paging) Reset()         { *m = Paging{} }
func (m *Paging) String() string { return proto.CompactTextString(m) }
func (*Paging) ProtoMessage()    {}
func (*Paging) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{36}
}
func (m *Paging) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Paging) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Paging.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Paging) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Paging.Merge(m, src)
}
func (m *Paging) XXX_Size() int {
	return m.Size()
}
func (m *Paging) XXX_DiscardUnknown() {
	xxx_messageInfo_Paging.DiscardUnknown(m)
}

var xxx_messageInfo_Paging proto.InternalMessageInfo

func (m *Paging) GetTotal() int32 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *Paging) GetIsEnd() bool {
	if m != nil {
		return m.IsEnd
	}
	return false
}

func (m *Paging) GetNext() string {
	if m != nil {
		return m.Next
	}
	return ""
}

func (m *Paging) GetPrev() string {
	if m != nil {
		return m.Prev
	}
	return ""
}

type ArgSaveAuthTopics struct {
	TopicID              int64           `protobuf:"varint,1,opt,name=TopicID,proto3" json:"TopicID,omitempty"`
	AuthTopics           []*ArgAuthTopic `protobuf:"bytes,2,rep,name=AuthTopics,proto3" json:"AuthTopics,omitempty"`
	Aid                  int64           `protobuf:"varint,3,opt,name=Aid,proto3" json:"Aid,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *ArgSaveAuthTopics) Reset()         { *m = ArgSaveAuthTopics{} }
func (m *ArgSaveAuthTopics) String() string { return proto.CompactTextString(m) }
func (*ArgSaveAuthTopics) ProtoMessage()    {}
func (*ArgSaveAuthTopics) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{37}
}
func (m *ArgSaveAuthTopics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArgSaveAuthTopics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArgSaveAuthTopics.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArgSaveAuthTopics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArgSaveAuthTopics.Merge(m, src)
}
func (m *ArgSaveAuthTopics) XXX_Size() int {
	return m.Size()
}
func (m *ArgSaveAuthTopics) XXX_DiscardUnknown() {
	xxx_messageInfo_ArgSaveAuthTopics.DiscardUnknown(m)
}

var xxx_messageInfo_ArgSaveAuthTopics proto.InternalMessageInfo

func (m *ArgSaveAuthTopics) GetTopicID() int64 {
	if m != nil {
		return m.TopicID
	}
	return 0
}

func (m *ArgSaveAuthTopics) GetAuthTopics() []*ArgAuthTopic {
	if m != nil {
		return m.AuthTopics
	}
	return nil
}

func (m *ArgSaveAuthTopics) GetAid() int64 {
	if m != nil {
		return m.Aid
	}
	return 0
}

type ArgAuthTopic struct {
	TopicID              int64    `protobuf:"varint,1,opt,name=TopicID,proto3" json:"TopicID,omitempty"`
	Permission           string   `protobuf:"bytes,2,opt,name=Permission,proto3" json:"Permission,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ArgAuthTopic) Reset()         { *m = ArgAuthTopic{} }
func (m *ArgAuthTopic) String() string { return proto.CompactTextString(m) }
func (*ArgAuthTopic) ProtoMessage()    {}
func (*ArgAuthTopic) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{38}
}
func (m *ArgAuthTopic) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArgAuthTopic) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArgAuthTopic.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArgAuthTopic) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArgAuthTopic.Merge(m, src)
}
func (m *ArgAuthTopic) XXX_Size() int {
	return m.Size()
}
func (m *ArgAuthTopic) XXX_DiscardUnknown() {
	xxx_messageInfo_ArgAuthTopic.DiscardUnknown(m)
}

var xxx_messageInfo_ArgAuthTopic proto.InternalMessageInfo

func (m *ArgAuthTopic) GetTopicID() int64 {
	if m != nil {
		return m.TopicID
	}
	return 0
}

func (m *ArgAuthTopic) GetPermission() string {
	if m != nil {
		return m.Permission
	}
	return ""
}

type AuthTopicsResp struct {
	Items                []*AuthTopicInfo `protobuf:"bytes,1,rep,name=Items,proto3" json:"Items,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *AuthTopicsResp) Reset()         { *m = AuthTopicsResp{} }
func (m *AuthTopicsResp) String() string { return proto.CompactTextString(m) }
func (*AuthTopicsResp) ProtoMessage()    {}
func (*AuthTopicsResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{39}
}
func (m *AuthTopicsResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthTopicsResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthTopicsResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthTopicsResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthTopicsResp.Merge(m, src)
}
func (m *AuthTopicsResp) XXX_Size() int {
	return m.Size()
}
func (m *AuthTopicsResp) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthTopicsResp.DiscardUnknown(m)
}

var xxx_messageInfo_AuthTopicsResp proto.InternalMessageInfo

func (m *AuthTopicsResp) GetItems() []*AuthTopicInfo {
	if m != nil {
		return m.Items
	}
	return nil
}

type CatalogsResp struct {
	Items                []*TopicRootCatalogInfo `protobuf:"bytes,1,rep,name=Items,proto3" json:"Items,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *CatalogsResp) Reset()         { *m = CatalogsResp{} }
func (m *CatalogsResp) String() string { return proto.CompactTextString(m) }
func (*CatalogsResp) ProtoMessage()    {}
func (*CatalogsResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{40}
}
func (m *CatalogsResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CatalogsResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CatalogsResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CatalogsResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogsResp.Merge(m, src)
}
func (m *CatalogsResp) XXX_Size() int {
	return m.Size()
}
func (m *CatalogsResp) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogsResp.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogsResp proto.InternalMessageInfo

func (m *CatalogsResp) GetItems() []*TopicRootCatalogInfo {
	if m != nil {
		return m.Items
	}
	return nil
}

type ArgSaveCatalogs struct {
	TopicID              int64              `protobuf:"varint,1,opt,name=TopicID,proto3" json:"TopicID,omitempty"`
	Aid                  int64              `protobuf:"varint,2,opt,name=Aid,proto3" json:"Aid,omitempty"`
	ParentID             int64              `protobuf:"varint,3,opt,name=ParentID,proto3" json:"ParentID,omitempty"`
	Items                []*ArgTopicCatalog `protobuf:"bytes,4,rep,name=Items,proto3" json:"Items,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *ArgSaveCatalogs) Reset()         { *m = ArgSaveCatalogs{} }
func (m *ArgSaveCatalogs) String() string { return proto.CompactTextString(m) }
func (*ArgSaveCatalogs) ProtoMessage()    {}
func (*ArgSaveCatalogs) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{41}
}
func (m *ArgSaveCatalogs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArgSaveCatalogs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArgSaveCatalogs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArgSaveCatalogs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArgSaveCatalogs.Merge(m, src)
}
func (m *ArgSaveCatalogs) XXX_Size() int {
	return m.Size()
}
func (m *ArgSaveCatalogs) XXX_DiscardUnknown() {
	xxx_messageInfo_ArgSaveCatalogs.DiscardUnknown(m)
}

var xxx_messageInfo_ArgSaveCatalogs proto.InternalMessageInfo

func (m *ArgSaveCatalogs) GetTopicID() int64 {
	if m != nil {
		return m.TopicID
	}
	return 0
}

func (m *ArgSaveCatalogs) GetAid() int64 {
	if m != nil {
		return m.Aid
	}
	return 0
}

func (m *ArgSaveCatalogs) GetParentID() int64 {
	if m != nil {
		return m.ParentID
	}
	return 0
}

func (m *ArgSaveCatalogs) GetItems() []*ArgTopicCatalog {
	if m != nil {
		return m.Items
	}
	return nil
}

type ArgTopicFollow struct {
	TopicID              int64    `protobuf:"varint,1,opt,name=TopicID,proto3" json:"TopicID,omitempty"`
	Reason               string   `protobuf:"bytes,2,opt,name=Reason,proto3" json:"Reason,omitempty"`
	AllowViewCert        bool     `protobuf:"varint,3,opt,name=AllowViewCert,proto3" json:"AllowViewCert,omitempty"`
	Aid                  int64    `protobuf:"varint,4,opt,name=Aid,proto3" json:"Aid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ArgTopicFollow) Reset()         { *m = ArgTopicFollow{} }
func (m *ArgTopicFollow) String() string { return proto.CompactTextString(m) }
func (*ArgTopicFollow) ProtoMessage()    {}
func (*ArgTopicFollow) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{42}
}
func (m *ArgTopicFollow) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArgTopicFollow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArgTopicFollow.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArgTopicFollow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArgTopicFollow.Merge(m, src)
}
func (m *ArgTopicFollow) XXX_Size() int {
	return m.Size()
}
func (m *ArgTopicFollow) XXX_DiscardUnknown() {
	xxx_messageInfo_ArgTopicFollow.DiscardUnknown(m)
}

var xxx_messageInfo_ArgTopicFollow proto.InternalMessageInfo

func (m *ArgTopicFollow) GetTopicID() int64 {
	if m != nil {
		return m.TopicID
	}
	return 0
}

func (m *ArgTopicFollow) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *ArgTopicFollow) GetAllowViewCert() bool {
	if m != nil {
		return m.AllowViewCert
	}
	return false
}

func (m *ArgTopicFollow) GetAid() int64 {
	if m != nil {
		return m.Aid
	}
	return 0
}

type ArgAuditFollow struct {
	ID                   int64    `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Approve              bool     `protobuf:"varint,2,opt,name=Approve,proto3" json:"Approve,omitempty"`
	Reason               string   `protobuf:"bytes,3,opt,name=Reason,proto3" json:"Reason,omitempty"`
	Aid                  int64    `protobuf:"varint,4,opt,name=Aid,proto3" json:"Aid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ArgAuditFollow) Reset()         { *m = ArgAuditFollow{} }
func (m *ArgAuditFollow) String() string { return proto.CompactTextString(m) }
func (*ArgAuditFollow) ProtoMessage()    {}
func (*ArgAuditFollow) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{43}
}
func (m *ArgAuditFollow) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArgAuditFollow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArgAuditFollow.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArgAuditFollow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArgAuditFollow.Merge(m, src)
}
func (m *ArgAuditFollow) XXX_Size() int {
	return m.Size()
}
func (m *ArgAuditFollow) XXX_DiscardUnknown() {
	xxx_messageInfo_ArgAuditFollow.DiscardUnknown(m)
}

var xxx_messageInfo_ArgAuditFollow proto.InternalMessageInfo

func (m *ArgAuditFollow) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *ArgAuditFollow) GetApprove() bool {
	if m != nil {
		return m.Approve
	}
	return false
}

func (m *ArgAuditFollow) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *ArgAuditFollow) GetAid() int64 {
	if m != nil {
		return m.Aid
	}
	return 0
}

type StatusResp struct {
	Status               int32    `protobuf:"varint,1,opt,name=Status,proto3" json:"Status,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StatusResp) Reset()         { *m = StatusResp{} }
func (m *StatusResp) String() string { return proto.CompactTextString(m) }
func (*StatusResp) ProtoMessage()    {}
func (*StatusResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{44}
}
func (m *StatusResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatusResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StatusResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StatusResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatusResp.Merge(m, src)
}
func (m *StatusResp) XXX_Size() int {
	return m.Size()
}
func (m *StatusResp) XXX_DiscardUnknown() {
	xxx_messageInfo_StatusResp.DiscardUnknown(m)
}

var xxx_messageInfo_StatusResp proto.InternalMessageInfo

func (m *StatusResp) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

type ArgTopicInvite struct {
	TopicID              int64    `protobuf:"varint,1,opt,name=TopicID,proto3" json:"TopicID,omitempty"`
	AccountID            int64    `protobuf:"varint,2,opt,name=AccountID,proto3" json:"AccountID,omitempty"`
	Aid                  int64    `protobuf:"varint,3,opt,name=Aid,proto3" json:"Aid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ArgTopicInvite) Reset()         { *m = ArgTopicInvite{} }
func (m *ArgTopicInvite) String() string { return proto.CompactTextString(m) }
func (*ArgTopicInvite) ProtoMessage()    {}
func (*ArgTopicInvite) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{45}
}
func (m *ArgTopicInvite) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArgTopicInvite) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArgTopicInvite.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArgTopicInvite) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArgTopicInvite.Merge(m, src)
}
func (m *ArgTopicInvite) XXX_Size() int {
	return m.Size()
}
func (m *ArgTopicInvite) XXX_DiscardUnknown() {
	xxx_messageInfo_ArgTopicInvite.DiscardUnknown(m)
}

var xxx_messageInfo_ArgTopicInvite proto.InternalMessageInfo

func (m *ArgTopicInvite) GetTopicID() int64 {
	if m != nil {
		return m.TopicID
	}
	return 0
}

func (m *ArgTopicInvite) GetAccountID() int64 {
	if m != nil {
		return m.AccountID
	}
	return 0
}

func (m *ArgTopicInvite) GetAid() int64 {
	if m != nil {
		return m.Aid
	}
	return 0
}

type ArgProcessInvite struct {
	ID                   int64    `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Result               bool     `protobuf:"varint,2,opt,name=Result,proto3" json:"Result,omitempty"`
	Aid                  int64    `protobuf:"varint,3,opt,name=Aid,proto3" json:"Aid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ArgProcessInvite) Reset()         { *m = ArgProcessInvite{} }
func (m *ArgProcessInvite) String() string { return proto.CompactTextString(m) }
func (*ArgProcessInvite) ProtoMessage()    {}
func (*ArgProcessInvite) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{46}
}
func (m *ArgProcessInvite) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArgProcessInvite) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArgProcessInvite.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArgProcessInvite) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArgProcessInvite.Merge(m, src)
}
func (m *ArgProcessInvite) XXX_Size() int {
	return m.Size()
}
func (m *ArgProcessInvite) XXX_DiscardUnknown() {
	xxx_messageInfo_ArgProcessInvite.DiscardUnknown(m)
}

var xxx_messageInfo_ArgProcessInvite proto.InternalMessageInfo

func (m *ArgProcessInvite) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *ArgProcessInvite) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *ArgProcessInvite) GetAid() int64 {
	if m != nil {
		return m.Aid
	}
	return 0
}

type BoolResp struct {
	Result               bool     `protobuf:"varint,1,opt,name=Result,proto3" json:"Result,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BoolResp) Reset()         { *m = BoolResp{} }
func (m *BoolResp) String() string { return proto.CompactTextString(m) }
func (*BoolResp) ProtoMessage()    {}
func (*BoolResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{47}
}
func (m *BoolResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BoolResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BoolResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BoolResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BoolResp.Merge(m, src)
}
func (m *BoolResp) XXX_Size() int {
	return m.Size()
}
func (m *BoolResp) XXX_DiscardUnknown() {
	xxx_messageInfo_BoolResp.DiscardUnknown(m)
}

var xxx_messageInfo_BoolResp proto.InternalMessageInfo

func (m *BoolResp) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

type ArgIsTopicMember struct {
	AccountID            int64    `protobuf:"varint,1,opt,name=AccountID,proto3" json:"AccountID,omitempty"`
	TopicID              int64    `protobuf:"varint,2,opt,name=TopicID,proto3" json:"TopicID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ArgIsTopicMember) Reset()         { *m = ArgIsTopicMember{} }
func (m *ArgIsTopicMember) String() string { return proto.CompactTextString(m) }
func (*ArgIsTopicMember) ProtoMessage()    {}
func (*ArgIsTopicMember) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{48}
}
func (m *ArgIsTopicMember) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArgIsTopicMember) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArgIsTopicMember.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArgIsTopicMember) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArgIsTopicMember.Merge(m, src)
}
func (m *ArgIsTopicMember) XXX_Size() int {
	return m.Size()
}
func (m *ArgIsTopicMember) XXX_DiscardUnknown() {
	xxx_messageInfo_ArgIsTopicMember.DiscardUnknown(m)
}

var xxx_messageInfo_ArgIsTopicMember proto.InternalMessageInfo

func (m *ArgIsTopicMember) GetAccountID() int64 {
	if m != nil {
		return m.AccountID
	}
	return 0
}

func (m *ArgIsTopicMember) GetTopicID() int64 {
	if m != nil {
		return m.TopicID
	}
	return 0
}

type ArgHasInvite struct {
	AccountID            int64    `protobuf:"varint,1,opt,name=AccountID,proto3" json:"AccountID,omitempty"`
	TopicID              int64    `protobuf:"varint,2,opt,name=TopicID,proto3" json:"TopicID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ArgHasInvite) Reset()         { *m = ArgHasInvite{} }
func (m *ArgHasInvite) String() string { return proto.CompactTextString(m) }
func (*ArgHasInvite) ProtoMessage()    {}
func (*ArgHasInvite) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{49}
}
func (m *ArgHasInvite) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArgHasInvite) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArgHasInvite.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArgHasInvite) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArgHasInvite.Merge(m, src)
}
func (m *ArgHasInvite) XXX_Size() int {
	return m.Size()
}
func (m *ArgHasInvite) XXX_DiscardUnknown() {
	xxx_messageInfo_ArgHasInvite.DiscardUnknown(m)
}

var xxx_messageInfo_ArgHasInvite proto.InternalMessageInfo

func (m *ArgHasInvite) GetAccountID() int64 {
	if m != nil {
		return m.AccountID
	}
	return 0
}

func (m *ArgHasInvite) GetTopicID() int64 {
	if m != nil {
		return m.TopicID
	}
	return 0
}

func init() {
	proto.RegisterType((*EmptyStruct)(nil), "service.topic.EmptyStruct")
	proto.RegisterType((*MemberRoleReply)(nil), "service.topic.MemberRoleReply")
	proto.RegisterType((*Creator)(nil), "service.topic.Creator")
	proto.RegisterType((*TopicInfo)(nil), "service.topic.TopicInfo")
	proto.RegisterType((*TopicRootCatalogInfo)(nil), "service.topic.TopicRootCatalogInfo")
	proto.RegisterType((*TopicParentCatalogInfo)(nil), "service.topic.TopicParentCatalogInfo")
	proto.RegisterType((*TopicChildCatalogInfo)(nil), "service.topic.TopicChildCatalogInfo")
	proto.RegisterType((*TargetArticle)(nil), "service.topic.TargetArticle")
	proto.RegisterType((*TopicStat)(nil), "service.topic.TopicStat")
	proto.RegisterType((*TopicMetaInfo)(nil), "service.topic.TopicMetaInfo")
	proto.RegisterType((*TopicPermissionInfo)(nil), "service.topic.TopicPermissionInfo")
	proto.RegisterType((*TopicReq)(nil), "service.topic.TopicReq")
	proto.RegisterType((*TopicMetaReq)(nil), "service.topic.TopicMetaReq")
	proto.RegisterType((*TopicMemberRoleReq)(nil), "service.topic.TopicMemberRoleReq")
	proto.RegisterType((*TopicPermissionReq)(nil), "service.topic.TopicPermissionReq")
	proto.RegisterType((*UserTopicsReq)(nil), "service.topic.UserTopicsReq")
	proto.RegisterType((*UserTopicsResp)(nil), "service.topic.UserTopicsResp")
	proto.RegisterType((*AllTopicsResp)(nil), "service.topic.AllTopicsResp")
	proto.RegisterType((*AidReq)(nil), "service.topic.AidReq")
	proto.RegisterType((*IDsResp)(nil), "service.topic.IDsResp")
	proto.RegisterType((*IDReq)(nil), "service.topic.IDReq")
	proto.RegisterType((*IDResp)(nil), "service.topic.IDResp")
	proto.RegisterType((*TopicResp)(nil), "service.topic.TopicResp")
	proto.RegisterType((*TopicMemberInfo)(nil), "service.topic.TopicMemberInfo")
	proto.RegisterType((*AuthTopicInfo)(nil), "service.topic.AuthTopicInfo")
	proto.RegisterType((*DiscussCategoryInfo)(nil), "service.topic.DiscussCategoryInfo")
	proto.RegisterType((*ArgChangeOwner)(nil), "service.topic.ArgChangeOwner")
	proto.RegisterType((*ArgCreateTopic)(nil), "service.topic.ArgCreateTopic")
	proto.RegisterType((*ArgUpdateTopic)(nil), "service.topic.ArgUpdateTopic")
	proto.RegisterType((*TopicMembersPagedResp)(nil), "service.topic.TopicMembersPagedResp")
	proto.RegisterType((*ArgBatchSavedTopicMember)(nil), "service.topic.ArgBatchSavedTopicMember")
	proto.RegisterType((*ArgTopicMember)(nil), "service.topic.ArgTopicMember")
	proto.RegisterType((*ArgTopicCatalog)(nil), "service.topic.ArgTopicCatalog")
	proto.RegisterType((*ArgCanEditTopicsReq)(nil), "service.topic.ArgCanEditTopicsReq")
	proto.RegisterType((*CanEditTopicsResp)(nil), "service.topic.CanEditTopicsResp")
	proto.RegisterType((*CanEditTopicItem)(nil), "service.topic.CanEditTopicItem")
	proto.RegisterType((*Paging)(nil), "service.topic.Paging")
	proto.RegisterType((*ArgSaveAuthTopics)(nil), "service.topic.ArgSaveAuthTopics")
	proto.RegisterType((*ArgAuthTopic)(nil), "service.topic.ArgAuthTopic")
	proto.RegisterType((*AuthTopicsResp)(nil), "service.topic.AuthTopicsResp")
	proto.RegisterType((*CatalogsResp)(nil), "service.topic.CatalogsResp")
	proto.RegisterType((*ArgSaveCatalogs)(nil), "service.topic.ArgSaveCatalogs")
	proto.RegisterType((*ArgTopicFollow)(nil), "service.topic.ArgTopicFollow")
	proto.RegisterType((*ArgAuditFollow)(nil), "service.topic.ArgAuditFollow")
	proto.RegisterType((*StatusResp)(nil), "service.topic.StatusResp")
	proto.RegisterType((*ArgTopicInvite)(nil), "service.topic.ArgTopicInvite")
	proto.RegisterType((*ArgProcessInvite)(nil), "service.topic.ArgProcessInvite")
	proto.RegisterType((*BoolResp)(nil), "service.topic.BoolResp")
	proto.RegisterType((*ArgIsTopicMember)(nil), "service.topic.ArgIsTopicMember")
	proto.RegisterType((*ArgHasInvite)(nil), "service.topic.ArgHasInvite")
}

func init() { proto.RegisterFile("pb.proto", fileDescriptor_f80abaa17e25ccc8) }

var fileDescriptor_f80abaa17e25ccc8 = []byte{
	// 2863 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x5a, 0x4b, 0x6f, 0x23, 0xc7,
	0xf1, 0x37, 0xdf, 0x64, 0x51, 0xa4, 0xa4, 0x96, 0x56, 0xff, 0x59, 0x7a, 0x57, 0xd4, 0x7f, 0xb2,
	0x36, 0x94, 0xc0, 0x96, 0x03, 0xc5, 0x76, 0x1e, 0x36, 0x6c, 0xf3, 0xb1, 0x5e, 0x72, 0xbd, 0x0f,
	0xb9, 0x57, 0xeb, 0x00, 0x9b, 0x20, 0xc2, 0x2c, 0xd9, 0xa2, 0x06, 0x21, 0x39, 0xdc, 0x99, 0xa1,
	0xb4, 0xb2, 0x13, 0x04, 0x41, 0x3e, 0x40, 0x0e, 0x01, 0xf2, 0x11, 0x72, 0x4c, 0x6e, 0x0e, 0x90,
	0x1c, 0x73, 0xc9, 0x31, 0x9f, 0x80, 0x08, 0x36, 0x37, 0xde, 0x92, 0x53, 0x8e, 0x41, 0x57, 0xf7,
	0xcc, 0xf4, 0x3c, 0xc8, 0xd5, 0x3e, 0xf2, 0x00, 0x92, 0x1b, 0xbb, 0xea, 0xd7, 0xd5, 0xd5, 0xd5,
	0x5d, 0x8f, 0xae, 0x21, 0x14, 0x27, 0x0f, 0xf7, 0x26, 0xb6, 0xe5, 0x5a, 0xa4, 0xe2, 0x30, 0xfb,
	0xd4, 0xec, 0xb1, 0x3d, 0xd7, 0x9a, 0x98, 0xbd, 0xda, 0x9b, 0x03, 0xd3, 0x3d, 0x99, 0x3e, 0xdc,
	0xeb, 0x59, 0xa3, 0xb7, 0x06, 0xd6, 0xc0, 0x7a, 0x0b, 0x51, 0x0f, 0xa7, 0xc7, 0x38, 0xc2, 0x01,
	0xfe, 0x12, 0xb3, 0xf5, 0x0a, 0x94, 0xaf, 0x8f, 0x26, 0xee, 0xf9, 0x3d, 0xd7, 0x9e, 0xf6, 0x5c,
	0xfd, 0x01, 0xac, 0xde, 0x66, 0xa3, 0x87, 0xcc, 0xa6, 0xd6, 0x90, 0x51, 0x36, 0x19, 0x9e, 0x93,
	0xaf, 0x42, 0xb1, 0xeb, 0x08, 0xa2, 0x96, 0xda, 0x49, 0xed, 0x16, 0x9b, 0x95, 0xf9, 0xac, 0x5e,
	0x32, 0x9d, 0xa3, 0x91, 0x40, 0xfa, 0x6c, 0x72, 0x05, 0xb2, 0x7c, 0x9e, 0x96, 0xde, 0x49, 0xed,
	0x96, 0x9a, 0xc5, 0xf9, 0xac, 0x9e, 0xb5, 0xb9, 0x1c, 0xa4, 0xea, 0xbf, 0x4a, 0x41, 0xa1, 0x65,
	0x33, 0xc3, 0xb5, 0x6c, 0xb2, 0x05, 0xe9, 0x6e, 0x1b, 0xc5, 0x65, 0x9a, 0xf9, 0xf9, 0xac, 0x9e,
	0x36, 0xfb, 0x34, 0xdd, 0x6d, 0xf3, 0xc5, 0xee, 0x3b, 0xcc, 0xbe, 0x63, 0x8c, 0x3c, 0x29, 0xb8,
	0xd8, 0xd4, 0x61, 0xf6, 0xd1, 0xd8, 0x18, 0x31, 0xea, 0xb3, 0x89, 0x0e, 0xf9, 0xc6, 0xa9, 0xe1,
	0x1a, 0xb6, 0x96, 0x41, 0x20, 0xcc, 0x67, 0xf5, 0xbc, 0x81, 0x14, 0x2a, 0x39, 0xe4, 0x6d, 0x58,
	0xe9, 0x8e, 0x5d, 0xdb, 0xea, 0x4f, 0x7b, 0xae, 0x69, 0x8d, 0xb5, 0x2c, 0x22, 0xd7, 0xe6, 0xb3,
	0xfa, 0x8a, 0xa9, 0xd0, 0x69, 0x08, 0xa5, 0xff, 0x36, 0x0b, 0xa5, 0x43, 0x6e, 0xcc, 0xee, 0xf8,
	0xd8, 0x22, 0xd5, 0x40, 0x55, 0x54, 0x91, 0x40, 0x36, 0x50, 0x8f, 0xe2, 0x6f, 0xb2, 0x15, 0xd6,
	0xc5, 0x5f, 0xbf, 0x0a, 0xe9, 0xe6, 0x40, 0xac, 0x4a, 0xd3, 0xcd, 0x01, 0xd1, 0x23, 0xfa, 0xe4,
	0x90, 0x13, 0xa2, 0x71, 0x4c, 0x63, 0x38, 0xb4, 0xce, 0xda, 0xa6, 0xd3, 0x9b, 0x3a, 0x8e, 0x96,
	0xe7, 0x36, 0xa7, 0x21, 0x1a, 0xb9, 0x02, 0x25, 0x1c, 0xb7, 0x4e, 0x0c, 0x57, 0x2b, 0x20, 0x20,
	0x20, 0x70, 0x6e, 0xd7, 0x39, 0xb0, 0xcd, 0x53, 0xc3, 0x65, 0x5a, 0x51, 0x70, 0x7d, 0x02, 0x79,
	0x1d, 0xaa, 0x9f, 0x99, 0xec, 0xec, 0x80, 0xd9, 0x23, 0xd3, 0x71, 0xb8, 0x16, 0x25, 0xd4, 0x22,
	0x42, 0xe5, 0xb8, 0xeb, 0x7d, 0xd3, 0x55, 0x70, 0x20, 0x70, 0x61, 0x2a, 0xc7, 0xdd, 0xb4, 0xcc,
	0xb1, 0x82, 0x2b, 0x0b, 0x5c, 0x98, 0x4a, 0x76, 0x61, 0xb5, 0x65, 0xb8, 0xc6, 0xd0, 0x1a, 0xf0,
	0x85, 0x0e, 0xcf, 0x27, 0x4c, 0x5b, 0x41, 0x60, 0x94, 0xcc, 0xf5, 0x47, 0xf3, 0x77, 0xac, 0x11,
	0xd3, 0x2a, 0x88, 0x09, 0x08, 0xe4, 0xeb, 0xfe, 0x2d, 0xd2, 0xaa, 0x3b, 0xa9, 0xdd, 0xf2, 0xfe,
	0xd6, 0x5e, 0xc8, 0x03, 0xf6, 0x24, 0x97, 0xfa, 0x97, 0xed, 0x0a, 0x94, 0xf0, 0x27, 0xeb, 0x37,
	0x5c, 0x6d, 0x15, 0x0f, 0x32, 0x20, 0x70, 0xee, 0xfd, 0x49, 0x5f, 0x72, 0xd7, 0x04, 0xd7, 0x27,
	0x90, 0x37, 0x20, 0x7b, 0xcf, 0x35, 0x5c, 0x6d, 0x1d, 0x97, 0xd2, 0x22, 0x4b, 0xa1, 0x56, 0x9c,
	0x4f, 0x11, 0xa5, 0xff, 0x35, 0x05, 0x9b, 0x48, 0xa3, 0x96, 0xe5, 0xca, 0x6d, 0x5d, 0xf8, 0x12,
	0xad, 0x41, 0xe6, 0x1e, 0x7b, 0x84, 0x37, 0x28, 0x47, 0xf9, 0x4f, 0x8e, 0x42, 0x3b, 0x89, 0x0b,
	0x84, 0xbf, 0xc9, 0x26, 0xe4, 0x28, 0x3b, 0xee, 0xb6, 0xf1, 0x5e, 0x64, 0xa8, 0x18, 0x90, 0x77,
	0xa1, 0xd0, 0xb0, 0x5d, 0xb3, 0x37, 0x64, 0x78, 0x1d, 0xca, 0xfb, 0x57, 0xa2, 0x9a, 0x1a, 0xf6,
	0x80, 0xb9, 0x12, 0x43, 0x3d, 0x30, 0x69, 0x40, 0xb1, 0x75, 0x62, 0x0e, 0xfb, 0x36, 0x1b, 0x6b,
	0xc5, 0x9d, 0xcc, 0x6e, 0x79, 0xff, 0xb5, 0xa4, 0x2d, 0x1e, 0x18, 0x36, 0x1b, 0xab, 0x1b, 0xa2,
	0xfe, 0x34, 0xfd, 0x6f, 0x29, 0xd8, 0x4a, 0x06, 0xfd, 0x33, 0x76, 0x9d, 0x7b, 0x19, 0xbb, 0xfe,
	0x28, 0xb6, 0xeb, 0x6b, 0x49, 0xbb, 0x46, 0x4c, 0xf2, 0xa6, 0x7f, 0x93, 0x82, 0x4b, 0x89, 0x98,
	0xff, 0xd4, 0x3d, 0xeb, 0x7f, 0x49, 0x43, 0x25, 0xc4, 0x8a, 0x69, 0xba, 0x09, 0xb9, 0x43, 0xd3,
	0xf5, 0xc2, 0x37, 0x15, 0x03, 0xa2, 0x41, 0xe1, 0xfa, 0xe3, 0x1e, 0xb3, 0x27, 0xae, 0x8c, 0x6d,
	0xde, 0x10, 0xc3, 0xcc, 0xc8, 0x18, 0xb0, 0xfb, 0xf6, 0xd0, 0xd1, 0xb2, 0x3b, 0x19, 0xee, 0xa6,
	0x3e, 0x81, 0x73, 0x6f, 0x99, 0x3f, 0x64, 0x2d, 0x6b, 0x3a, 0x76, 0x71, 0x07, 0x39, 0x1a, 0x10,
	0x78, 0x90, 0x6b, 0x9b, 0xce, 0xd0, 0x07, 0xe4, 0x11, 0x10, 0xa2, 0x91, 0x1d, 0x28, 0x53, 0x76,
	0x6a, 0x3a, 0x12, 0x52, 0x40, 0x88, 0x4a, 0xe2, 0x52, 0x5a, 0xd6, 0x68, 0xc4, 0x6f, 0x1d, 0x42,
	0x8a, 0x42, 0x8a, 0x4a, 0x0b, 0x3b, 0x7f, 0x69, 0xa9, 0xf3, 0x43, 0xd4, 0xf9, 0x95, 0x50, 0x53,
	0xbe, 0x50, 0xa8, 0xd1, 0xbf, 0x4c, 0xc9, 0xd8, 0xc5, 0xc3, 0x01, 0xd9, 0x87, 0xb2, 0xc8, 0x8c,
	0x42, 0x3d, 0x6e, 0xea, 0x9c, 0xc8, 0x3e, 0x22, 0x75, 0x1e, 0xf5, 0x38, 0x9d, 0xaa, 0x20, 0xf2,
	0x0e, 0xac, 0xc8, 0x03, 0x12, 0x93, 0xd2, 0x38, 0x69, 0x7d, 0x3e, 0xab, 0x57, 0x0c, 0x41, 0x97,
	0xb3, 0x42, 0x30, 0xf2, 0x01, 0xac, 0xca, 0xe4, 0x60, 0x5a, 0x63, 0x31, 0x13, 0xaf, 0x57, 0x73,
	0x73, 0x3e, 0xab, 0xaf, 0xf5, 0x7d, 0x96, 0x9c, 0x1c, 0x05, 0xeb, 0xbf, 0xe7, 0xd7, 0x83, 0x2b,
	0x7e, 0x9b, 0xb9, 0x06, 0x5e, 0xe4, 0x37, 0xa0, 0xd4, 0x32, 0xc6, 0x1f, 0x5b, 0x3c, 0xad, 0xc8,
	0xc4, 0x5f, 0x9d, 0xcf, 0xea, 0xd0, 0x33, 0xc6, 0x47, 0xc7, 0x48, 0xa5, 0x01, 0x80, 0xbc, 0x0e,
	0x85, 0x96, 0x31, 0xe6, 0xa9, 0x01, 0x35, 0x2e, 0x36, 0x57, 0xe6, 0xb3, 0x7a, 0x91, 0x63, 0x59,
	0xdf, 0x74, 0xa9, 0xc7, 0x24, 0x97, 0x21, 0xf3, 0xb1, 0x71, 0x8a, 0xba, 0x15, 0x9b, 0x85, 0xf9,
	0xac, 0x9e, 0x39, 0x36, 0x4e, 0x29, 0xa7, 0x49, 0x11, 0x3c, 0x0b, 0xa0, 0x1b, 0x28, 0x22, 0x4e,
	0x4d, 0x76, 0x46, 0x3d, 0x26, 0xb7, 0x90, 0x58, 0x94, 0xdb, 0x78, 0xea, 0x88, 0xcb, 0x25, 0x2c,
	0x24, 0xf4, 0x3a, 0x72, 0x90, 0x41, 0x43, 0xb0, 0x50, 0x1d, 0x93, 0x5f, 0x5e, 0xc7, 0xbc, 0x05,
	0x10, 0x54, 0x41, 0x78, 0xf1, 0x4a, 0xcd, 0xd5, 0xf9, 0xac, 0x5e, 0x96, 0xc7, 0x86, 0x45, 0x8d,
	0x02, 0xd1, 0x7f, 0x9d, 0x82, 0x0d, 0x11, 0x03, 0xfd, 0x7c, 0x87, 0x36, 0x7c, 0x2f, 0x96, 0x43,
	0x53, 0x28, 0x6c, 0x63, 0x3e, 0xab, 0xaf, 0x72, 0xc3, 0x1c, 0x4d, 0x7c, 0x56, 0x2c, 0xb1, 0xaa,
	0x0a, 0xa7, 0x9f, 0x45, 0xe1, 0xcc, 0xd3, 0x15, 0xfe, 0x08, 0x8a, 0x22, 0x4f, 0xb1, 0x47, 0x0b,
	0x6b, 0x31, 0xee, 0x1b, 0x0e, 0xbb, 0x6d, 0x38, 0xae, 0xa7, 0x00, 0x0d, 0x08, 0xfa, 0x17, 0xb0,
	0xe2, 0xdf, 0x17, 0x2e, 0xe5, 0x75, 0x28, 0x88, 0x9a, 0xc9, 0x13, 0x85, 0xa7, 0x87, 0x6e, 0x72,
	0x64, 0xf6, 0xa9, 0xc7, 0x24, 0xaf, 0x41, 0xa9, 0xd1, 0xc3, 0x4b, 0xd8, 0x6d, 0xa3, 0xd4, 0x8c,
	0xb8, 0x06, 0x86, 0xd9, 0xa7, 0x01, 0x27, 0xbc, 0x78, 0x26, 0xba, 0xf8, 0x4f, 0x53, 0x40, 0xe4,
	0xea, 0x41, 0xb1, 0xfa, 0xef, 0xd2, 0x21, 0x38, 0xb2, 0x7f, 0xb9, 0x0e, 0x5f, 0x40, 0x85, 0xd7,
	0xc3, 0x28, 0xd3, 0xe1, 0xab, 0x87, 0xa4, 0xa6, 0x16, 0x4a, 0xad, 0x43, 0xee, 0x96, 0x39, 0x32,
	0xbd, 0xe8, 0x52, 0x9a, 0xcf, 0xea, 0xb9, 0x21, 0x27, 0x50, 0x41, 0xe7, 0xc5, 0xf5, 0xdd, 0xe3,
	0x63, 0x87, 0x79, 0x51, 0x04, 0x8b, 0x6b, 0x0b, 0x29, 0x54, 0x72, 0xf4, 0x4f, 0xa0, 0xaa, 0x2e,
	0xee, 0x4c, 0xc8, 0xb7, 0x21, 0xd7, 0x75, 0xd9, 0xc8, 0xd1, 0x52, 0x98, 0x54, 0x13, 0xab, 0x25,
	0xee, 0x17, 0x62, 0x41, 0x93, 0x43, 0xa9, 0x98, 0xa1, 0xdf, 0x84, 0x4a, 0x63, 0x38, 0x7c, 0x39,
	0xb2, 0x0e, 0x21, 0xdf, 0x30, 0xfb, 0xdc, 0x1c, 0x6f, 0xc4, 0xcd, 0x81, 0x31, 0xcc, 0x10, 0xc4,
	0xa3, 0x25, 0xb6, 0x8e, 0x5d, 0xf8, 0x6b, 0x50, 0xe8, 0xb6, 0x85, 0x6e, 0x97, 0x21, 0xd3, 0x6d,
	0x0b, 0xcd, 0xa4, 0x7d, 0xcd, 0xbe, 0x43, 0x39, 0x4d, 0xff, 0x04, 0x72, 0xdd, 0xf6, 0x32, 0xaf,
	0xd2, 0xa0, 0xd0, 0x1d, 0xf7, 0x86, 0xd3, 0xbe, 0x97, 0x67, 0xbd, 0x21, 0xaf, 0x0a, 0x1a, 0x66,
	0x1f, 0x0d, 0x9e, 0xa1, 0xfc, 0xa7, 0xbe, 0x03, 0x79, 0x2e, 0xcc, 0x99, 0x2c, 0x92, 0xa6, 0xff,
	0xbd, 0x20, 0xf3, 0x0d, 0xa2, 0xfe, 0xf7, 0x54, 0xf9, 0x6f, 0x7e, 0xaa, 0x7c, 0x0d, 0xd6, 0x6e,
	0x4f, 0x5d, 0x76, 0xc7, 0x72, 0xcd, 0x63, 0xb3, 0x67, 0xe0, 0xa9, 0x11, 0x34, 0x69, 0x8c, 0x2e,
	0x6a, 0xb7, 0x89, 0x65, 0xbb, 0xc6, 0xd8, 0xd5, 0x36, 0xa4, 0xdd, 0x3d, 0x82, 0xff, 0xe8, 0xd9,
	0xbc, 0xc8, 0xa3, 0x87, 0xec, 0x01, 0xe9, 0x18, 0x8e, 0xb4, 0xcc, 0xa1, 0xf1, 0xd8, 0x1a, 0x5b,
	0xa3, 0x73, 0xed, 0x12, 0x0a, 0x4d, 0xe0, 0x90, 0x6f, 0x41, 0x41, 0x84, 0x6d, 0x47, 0xdb, 0x42,
	0xdf, 0xde, 0x4e, 0x5a, 0x40, 0x40, 0xb0, 0xec, 0xf6, 0xe0, 0xe4, 0x43, 0x28, 0x4a, 0x61, 0x8e,
	0xa6, 0xe1, 0xd4, 0xaf, 0x24, 0x4d, 0x8d, 0x3c, 0xbe, 0xa8, 0x3f, 0x89, 0x1c, 0xc0, 0xba, 0xbc,
	0x97, 0x2d, 0xc3, 0x65, 0x03, 0xcb, 0x36, 0x99, 0xa3, 0x5d, 0x46, 0x49, 0x7a, 0x44, 0x52, 0x18,
	0x77, 0x8e, 0x82, 0xe2, 0x93, 0xc9, 0xfb, 0x00, 0x8d, 0xa9, 0x7b, 0x22, 0x02, 0x97, 0x56, 0x43,
	0x51, 0xd1, 0x8a, 0xdc, 0x07, 0xa0, 0x10, 0x05, 0x4f, 0xbe, 0x23, 0xaf, 0x0f, 0x4f, 0xa2, 0xda,
	0xab, 0xc9, 0xe5, 0xbc, 0x5a, 0x94, 0xd1, 0x00, 0xae, 0x9f, 0xc1, 0x6a, 0xc4, 0x50, 0xe8, 0x6b,
	0xe1, 0x70, 0xa7, 0x86, 0x37, 0xa2, 0x76, 0x67, 0x44, 0x4f, 0x66, 0x61, 0x34, 0xa8, 0x29, 0x7d,
	0x18, 0x11, 0x13, 0xfc, 0xb1, 0xfe, 0x87, 0x14, 0x54, 0x42, 0x5b, 0x12, 0x5e, 0x10, 0xca, 0x7a,
	0x34, 0x20, 0x24, 0x78, 0x67, 0x3a, 0xd1, 0x3b, 0xb7, 0x01, 0x14, 0x8c, 0xd0, 0x47, 0xa1, 0xf0,
	0xf7, 0x80, 0x5a, 0x4d, 0x67, 0xc5, 0x7b, 0x40, 0xad, 0x9d, 0x83, 0xdd, 0xe4, 0x42, 0xbb, 0xf1,
	0xe2, 0x60, 0x3e, 0x88, 0x83, 0x3a, 0x83, 0x8d, 0x84, 0x23, 0x8e, 0x85, 0x50, 0x2d, 0x48, 0xe7,
	0x98, 0xa4, 0x83, 0x04, 0xee, 0x09, 0xcd, 0xc4, 0x1f, 0x76, 0x59, 0xff, 0x61, 0xa7, 0xff, 0x00,
	0xaa, 0x0d, 0x7b, 0xd0, 0x3a, 0x31, 0xc6, 0x03, 0x76, 0xf7, 0x6c, 0xcc, 0x6c, 0x55, 0x62, 0x2a,
	0x2c, 0x71, 0x07, 0xca, 0x87, 0x56, 0xa4, 0x28, 0xa0, 0x2a, 0x29, 0x21, 0x45, 0xfc, 0x32, 0x2d,
	0x16, 0xc0, 0x18, 0x81, 0x82, 0x3c, 0x50, 0xca, 0x07, 0x11, 0x1d, 0xca, 0xc2, 0x12, 0x9f, 0x19,
	0xc3, 0xa9, 0xbc, 0x00, 0x9d, 0x57, 0xa8, 0x4a, 0x24, 0x35, 0x28, 0x34, 0x07, 0x82, 0x8f, 0x3b,
	0xea, 0xa4, 0xa8, 0x47, 0xf0, 0xb7, 0x9a, 0x55, 0xb6, 0x7a, 0x91, 0xfc, 0x90, 0x10, 0x47, 0xf3,
	0xc9, 0x71, 0x34, 0x9a, 0x49, 0x0a, 0x4f, 0xcb, 0x24, 0xc5, 0x48, 0x26, 0x69, 0x16, 0xbd, 0xb3,
	0x6f, 0x66, 0x79, 0x26, 0xd3, 0xbf, 0xcc, 0xa3, 0x61, 0x44, 0x78, 0x14, 0x86, 0x89, 0x9e, 0xed,
	0x8b, 0x9a, 0x65, 0x1b, 0x4a, 0xdc, 0x14, 0x82, 0x8b, 0xb6, 0xe9, 0xa4, 0x69, 0x40, 0x22, 0x7b,
	0xb0, 0xae, 0x9a, 0x43, 0xe0, 0xd0, 0x4e, 0x9d, 0x0c, 0x8d, 0xb3, 0xc8, 0xdb, 0xb0, 0x19, 0xb1,
	0x8b, 0x98, 0x82, 0x36, 0xeb, 0x64, 0x69, 0x22, 0x97, 0xec, 0x42, 0xd5, 0xb7, 0x82, 0xc0, 0xa3,
	0xf1, 0x3a, 0x39, 0x1a, 0xa1, 0x73, 0x7d, 0x54, 0x83, 0x0a, 0x30, 0x1a, 0xb2, 0x93, 0xa7, 0x71,
	0x16, 0x97, 0xec, 0xe7, 0x62, 0x01, 0x2e, 0x21, 0xb8, 0x40, 0x23, 0x74, 0xb2, 0x0f, 0x1b, 0xe1,
	0x94, 0x2c, 0xe0, 0x98, 0x85, 0x3b, 0x45, 0x9a, 0xc4, 0xe4, 0x73, 0xc2, 0x01, 0x40, 0xcc, 0xc1,
	0x8c, 0xdc, 0x29, 0xd1, 0x24, 0x26, 0x9f, 0x13, 0x4e, 0xd5, 0x62, 0x0e, 0x26, 0xe7, 0x0e, 0xd0,
	0x24, 0x26, 0xee, 0xc2, 0xcb, 0x6c, 0x02, 0x5e, 0xc1, 0x5d, 0x94, 0x69, 0x84, 0x4e, 0xde, 0x85,
	0x4b, 0xd1, 0x44, 0x29, 0x26, 0x54, 0x71, 0xc2, 0x0a, 0x4d, 0x66, 0x7b, 0x0e, 0xb7, 0xea, 0x3b,
	0x5c, 0xf4, 0x32, 0x36, 0xf3, 0xc2, 0x81, 0x9a, 0xd5, 0xb0, 0xd3, 0x34, 0xd7, 0x63, 0x0e, 0xd2,
	0x2c, 0x2b, 0xb7, 0x9c, 0xe3, 0xd5, 0x63, 0xe1, 0x4c, 0xdf, 0xf2, 0xcd, 0xb5, 0x68, 0x75, 0xc4,
	0x29, 0x61, 0xab, 0x71, 0x4a, 0xd8, 0x26, 0x28, 0xc2, 0xdb, 0x76, 0x93, 0xc4, 0x4b, 0x06, 0xfd,
	0xc7, 0xb2, 0xb3, 0x25, 0x93, 0xee, 0x81, 0x31, 0x60, 0x7d, 0xac, 0x2e, 0x37, 0x21, 0xa7, 0xf4,
	0x31, 0xa8, 0x18, 0xf0, 0x4c, 0xc1, 0x21, 0xf7, 0xcc, 0xcf, 0x85, 0x07, 0xe5, 0xa8, 0x3f, 0x26,
	0xfb, 0x90, 0x6d, 0x1b, 0xae, 0xa1, 0x65, 0x2e, 0x94, 0xe6, 0x11, 0xab, 0xff, 0x04, 0xb4, 0x86,
	0x3d, 0x68, 0x1a, 0x6e, 0xef, 0xe4, 0x9e, 0x71, 0xca, 0xfa, 0x0a, 0x6a, 0x49, 0xe8, 0xfc, 0x66,
	0x50, 0x53, 0xa4, 0x71, 0xb1, 0xab, 0xd1, 0x1c, 0x6c, 0x0f, 0xd4, 0x07, 0xa3, 0x5f, 0x52, 0xc4,
	0x23, 0xea, 0x21, 0xc6, 0x0d, 0x75, 0xd9, 0x67, 0x4f, 0xab, 0x6b, 0x90, 0xb9, 0xeb, 0x37, 0xcc,
	0xf8, 0x4f, 0xfd, 0x67, 0x29, 0x58, 0xf5, 0xc4, 0xca, 0x23, 0xe7, 0xb1, 0xa5, 0xdb, 0x16, 0x37,
	0x0c, 0xa5, 0x76, 0x5e, 0xa1, 0x1e, 0xe1, 0x65, 0xb7, 0x0d, 0xf9, 0x3d, 0xec, 0xb6, 0xf5, 0x4f,
	0x60, 0x83, 0x27, 0x0b, 0xd1, 0x8b, 0x09, 0x5e, 0x8d, 0x55, 0x48, 0x1f, 0x8c, 0xe5, 0xb1, 0xa6,
	0x0f, 0xc6, 0x38, 0x76, 0xe4, 0x69, 0xa6, 0x0f, 0x1c, 0x2e, 0xf2, 0xd3, 0x29, 0xb3, 0xcf, 0xe5,
	0x86, 0xc4, 0x40, 0x3f, 0x87, 0xf5, 0x88, 0x24, 0x67, 0x42, 0xde, 0x09, 0x3f, 0xdb, 0xea, 0xd1,
	0x82, 0x57, 0x99, 0xc0, 0x71, 0xf2, 0xc9, 0x46, 0xde, 0x84, 0xfc, 0x81, 0x31, 0x30, 0xc7, 0x03,
	0x5c, 0xb5, 0xbc, 0x7f, 0x29, 0x32, 0x4f, 0x30, 0xa9, 0x04, 0xe9, 0xbf, 0x4b, 0xc3, 0x5a, 0x54,
	0xd4, 0x0b, 0xbd, 0x7e, 0x2e, 0x92, 0xcd, 0x22, 0xf5, 0x47, 0x3e, 0x5e, 0x7f, 0xe8, 0x91, 0xde,
	0x9d, 0x68, 0x59, 0x86, 0x1b, 0x75, 0xbb, 0xf1, 0x46, 0x9d, 0x68, 0x5b, 0x46, 0xc9, 0x09, 0x75,
	0x53, 0x29, 0xb1, 0x6e, 0x4a, 0xae, 0xbf, 0x61, 0x51, 0xfd, 0xad, 0x7f, 0xdf, 0xb3, 0x35, 0x76,
	0x7c, 0x2d, 0xd7, 0x18, 0x7a, 0x1e, 0x8d, 0x03, 0x4e, 0xed, 0x3a, 0xd7, 0xc7, 0x7d, 0xf9, 0x04,
	0x16, 0x03, 0xb4, 0x26, 0x7b, 0xec, 0xfa, 0xe5, 0x0e, 0x7b, 0xec, 0x72, 0xda, 0x81, 0xcd, 0x4e,
	0xbd, 0xeb, 0xc7, 0x7f, 0xeb, 0x3f, 0x82, 0xf5, 0x86, 0x3d, 0xe0, 0xae, 0xab, 0xd4, 0xb9, 0x8b,
	0x1d, 0xf7, 0xbd, 0x50, 0xfd, 0x2c, 0x7c, 0xf7, 0xd5, 0xb8, 0xef, 0xfa, 0x98, 0x50, 0xf9, 0x1c,
	0x77, 0xde, 0x0e, 0x3f, 0x81, 0x00, 0xbd, 0x64, 0xe1, 0x70, 0xb5, 0x99, 0x8e, 0x56, 0x9b, 0x7a,
	0x1b, 0xaa, 0xc1, 0x4a, 0x78, 0xb5, 0xf7, 0xc3, 0x57, 0x7b, 0x79, 0x95, 0x2f, 0x5b, 0x11, 0x5d,
	0x58, 0xf1, 0x1e, 0x1f, 0x49, 0x5d, 0x8d, 0x0b, 0x3d, 0x5f, 0xa4, 0xa8, 0x9f, 0x8b, 0x08, 0xc2,
	0x2d, 0xeb, 0xbf, 0x67, 0x16, 0x6f, 0x4f, 0x9a, 0x26, 0x1d, 0x14, 0x81, 0x18, 0xa8, 0x6d, 0x86,
	0x41, 0x4c, 0x58, 0xcc, 0x1f, 0x93, 0xb7, 0x3d, 0xb5, 0xb2, 0x89, 0x91, 0x3a, 0x12, 0xb8, 0x3c,
	0x8d, 0x3e, 0x0f, 0x22, 0xa5, 0xec, 0x02, 0x2f, 0xd6, 0x67, 0x0b, 0xf2, 0x94, 0x19, 0x8e, 0x6f,
	0x6a, 0x39, 0x22, 0xd7, 0xb0, 0xef, 0x63, 0x9d, 0xf1, 0x4c, 0xd6, 0x62, 0xb6, 0x2b, 0x7b, 0x5c,
	0x61, 0xa2, 0xb7, 0x9b, 0x6c, 0x70, 0xd0, 0x7d, 0x5c, 0xbb, 0x31, 0xed, 0x9b, 0xae, 0x5c, 0x3b,
	0xa1, 0x72, 0x6f, 0x4c, 0x26, 0xb6, 0x75, 0xca, 0xe4, 0x45, 0xf6, 0x86, 0x8a, 0x2e, 0x99, 0x90,
	0x2e, 0xf1, 0x55, 0xae, 0x01, 0x88, 0xee, 0xb1, 0x6c, 0xc2, 0xe4, 0x65, 0xcb, 0x59, 0xf8, 0x8b,
	0x1c, 0xe9, 0x0f, 0x02, 0x3b, 0x74, 0xc7, 0xa7, 0xa6, 0xcb, 0x96, 0xd8, 0xe1, 0x4a, 0xac, 0xed,
	0xa7, 0xe6, 0x92, 0xf8, 0x85, 0xbe, 0x05, 0x6b, 0x0d, 0x7b, 0x70, 0x60, 0x5b, 0x3d, 0xe6, 0x38,
	0x52, 0x7a, 0x74, 0xa7, 0xb8, 0x1f, 0x67, 0x3a, 0x94, 0xad, 0x77, 0x2a, 0x47, 0x09, 0xd2, 0x74,
	0x28, 0x36, 0x2d, 0x6b, 0xe8, 0xed, 0x46, 0xce, 0x4a, 0xa9, 0xb3, 0xf4, 0x9b, 0xb8, 0x62, 0xd7,
	0xb9, 0x78, 0x06, 0x5c, 0xf8, 0x46, 0xd2, 0x3f, 0x46, 0x77, 0xec, 0x18, 0x9e, 0xe6, 0xcf, 0x29,
	0x67, 0xff, 0x17, 0x6b, 0x3c, 0x52, 0x71, 0x87, 0x6e, 0x41, 0x59, 0x7d, 0xeb, 0x24, 0xa4, 0x79,
	0x85, 0x5d, 0x8b, 0xa6, 0x11, 0xd9, 0x4d, 0xeb, 0x40, 0x59, 0x7d, 0x17, 0x24, 0x08, 0x51, 0xd8,
	0xb5, 0x5a, 0x84, 0xad, 0xfc, 0x5f, 0x82, 0xbc, 0x0f, 0xc5, 0x36, 0x13, 0x6d, 0x4b, 0xb2, 0x99,
	0xb0, 0xd8, 0xa3, 0xa5, 0xb3, 0x3f, 0x80, 0x95, 0x1b, 0xcc, 0x0d, 0xfa, 0x77, 0xc9, 0x12, 0x12,
	0xfb, 0x2f, 0xde, 0x3e, 0xd4, 0x97, 0x65, 0x92, 0x31, 0x02, 0xf6, 0x52, 0x4d, 0xee, 0x40, 0x35,
	0x12, 0xb2, 0x77, 0xe2, 0xc2, 0xc2, 0x88, 0xa5, 0xf2, 0xda, 0x50, 0xb9, 0xc1, 0x5c, 0x45, 0x5c,
	0xf2, 0xd6, 0xae, 0x2e, 0x8a, 0xa1, 0xc2, 0xe1, 0xba, 0xb0, 0x79, 0x83, 0x79, 0xb1, 0xd0, 0xe9,
	0x98, 0xcc, 0x36, 0xec, 0xde, 0xc9, 0xf9, 0x02, 0x61, 0xaf, 0xc6, 0x6a, 0x0d, 0x25, 0xf0, 0x52,
	0xb8, 0x1a, 0x88, 0x92, 0xa9, 0xd0, 0x64, 0x2f, 0x26, 0xf3, 0x26, 0xac, 0x84, 0xa2, 0xf1, 0x76,
	0xb2, 0xc9, 0x3c, 0xfe, 0x52, 0x83, 0xdd, 0x80, 0xb2, 0x88, 0x63, 0x0b, 0xaf, 0xa4, 0x12, 0x67,
	0x6b, 0x97, 0x23, 0x6c, 0x25, 0x48, 0x75, 0xa0, 0xac, 0x46, 0xc5, 0xab, 0x49, 0xb9, 0xd4, 0x67,
	0x3f, 0x45, 0xa5, 0xad, 0x1b, 0xcc, 0xbd, 0xef, 0x30, 0x3b, 0x54, 0x6a, 0xb5, 0x1d, 0x12, 0x75,
	0x2b, 0xd1, 0x6d, 0xaf, 0x6d, 0xc5, 0x4c, 0x28, 0x54, 0xba, 0x8e, 0xc7, 0x28, 0x56, 0x94, 0x05,
	0xbd, 0xf3, 0x1c, 0x62, 0x3e, 0x84, 0x72, 0xc7, 0x70, 0xfc, 0x36, 0xe2, 0xff, 0x25, 0xbb, 0xc5,
	0xa3, 0x5a, 0x94, 0xe1, 0x47, 0xbc, 0x2e, 0x54, 0xc2, 0x61, 0xad, 0x1e, 0x37, 0x4e, 0x08, 0xb0,
	0x58, 0x54, 0x0b, 0xf2, 0x32, 0xa4, 0x2d, 0x3a, 0x29, 0xc1, 0x5e, 0x6a, 0xe0, 0x5b, 0x50, 0x09,
	0x07, 0xf6, 0x04, 0x7d, 0x42, 0x80, 0xa5, 0xd2, 0x1a, 0x50, 0x0a, 0x02, 0x6d, 0x42, 0x09, 0xe5,
	0x33, 0x17, 0xef, 0xaa, 0x83, 0xf1, 0xc8, 0xff, 0x0e, 0x43, 0x96, 0x2c, 0x57, 0x8b, 0x95, 0x3f,
	0xa1, 0xaf, 0x37, 0x8d, 0x20, 0xb2, 0x61, 0x5b, 0x6d, 0xe1, 0x61, 0x2d, 0xfc, 0xae, 0xa3, 0x8a,
	0xc0, 0x36, 0xf3, 0xb3, 0x89, 0xc0, 0x29, 0xdf, 0x03, 0xe2, 0x89, 0x50, 0xea, 0xe5, 0xff, 0x4f,
	0xfc, 0x87, 0x8b, 0xfa, 0x11, 0xaf, 0xa6, 0x2f, 0x87, 0xa0, 0x7e, 0xdf, 0x0d, 0x84, 0x07, 0x5f,
	0x21, 0x93, 0x85, 0x87, 0xbe, 0x52, 0xd6, 0xa2, 0x61, 0x22, 0xfa, 0x87, 0xbb, 0x6e, 0xb0, 0xf1,
	0xdb, 0xcc, 0x35, 0x62, 0x67, 0xa9, 0x7e, 0x76, 0xad, 0x2d, 0x6d, 0x17, 0x93, 0x4f, 0x51, 0xc7,
	0xe0, 0x2b, 0x1d, 0x3e, 0xe6, 0x49, 0x74, 0x4e, 0xe8, 0x13, 0x62, 0x2c, 0x26, 0x47, 0xbe, 0xf1,
	0xb5, 0x50, 0x64, 0x93, 0x0d, 0xad, 0xf1, 0xc0, 0x79, 0xde, 0x88, 0xd0, 0x86, 0xf5, 0xb0, 0xed,
	0xb8, 0x8c, 0x85, 0x07, 0xbc, 0x40, 0x4a, 0x73, 0xfd, 0x8f, 0x4f, 0xb6, 0x53, 0x7f, 0x7a, 0xb2,
	0x9d, 0xfa, 0xf3, 0x93, 0xed, 0xd4, 0x83, 0x8c, 0x31, 0x31, 0x1f, 0xe6, 0xf1, 0x5f, 0x8d, 0xdf,
	0xf8, 0x47, 0x00, 0x00, 0x00, 0xff, 0xff, 0x21, 0xf4, 0x81, 0x50, 0x1f, 0x29, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// TopicClient is the client API for Topic service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type TopicClient interface {
	CreateTopic(ctx context.Context, in *ArgCreateTopic, opts ...grpc.CallOption) (*IDResp, error)
	UpdateTopic(ctx context.Context, in *ArgUpdateTopic, opts ...grpc.CallOption) (*EmptyStruct, error)
	DelTopic(ctx context.Context, in *IDReq, opts ...grpc.CallOption) (*EmptyStruct, error)
	GetTopicResp(ctx context.Context, in *IDReq, opts ...grpc.CallOption) (*TopicResp, error)
	ChangeOwner(ctx context.Context, in *ArgChangeOwner, opts ...grpc.CallOption) (*EmptyStruct, error)
	SaveAuthTopics(ctx context.Context, in *ArgSaveAuthTopics, opts ...grpc.CallOption) (*EmptyStruct, error)
	GetAuthTopics(ctx context.Context, in *IDReq, opts ...grpc.CallOption) (*AuthTopicsResp, error)
	GetCatalogsHierarchy(ctx context.Context, in *IDReq, opts ...grpc.CallOption) (*CatalogsResp, error)
	GetCatalogTaxonomiesHierarchy(ctx context.Context, in *IDReq, opts ...grpc.CallOption) (*CatalogsResp, error)
	SaveCatalogs(ctx context.Context, in *ArgSaveCatalogs, opts ...grpc.CallOption) (*EmptyStruct, error)
	FollowTopic(ctx context.Context, in *ArgTopicFollow, opts ...grpc.CallOption) (*StatusResp, error)
	AuditFollow(ctx context.Context, in *ArgAuditFollow, opts ...grpc.CallOption) (*EmptyStruct, error)
	GetUserCanEditTopicIDs(ctx context.Context, in *AidReq, opts ...grpc.CallOption) (*IDsResp, error)
	GetFollowedTopicsIDs(ctx context.Context, in *AidReq, opts ...grpc.CallOption) (*IDsResp, error)
	HasTaxonomy(ctx context.Context, in *TopicReq, opts ...grpc.CallOption) (*BoolResp, error)
	IsTopicMember(ctx context.Context, in *ArgIsTopicMember, opts ...grpc.CallOption) (*BoolResp, error)
	Invite(ctx context.Context, in *ArgTopicInvite, opts ...grpc.CallOption) (*EmptyStruct, error)
	ProcessInvite(ctx context.Context, in *ArgProcessInvite, opts ...grpc.CallOption) (*EmptyStruct, error)
	HasInvite(ctx context.Context, in *ArgHasInvite, opts ...grpc.CallOption) (*BoolResp, error)
	GetAllTopics(ctx context.Context, in *EmptyStruct, opts ...grpc.CallOption) (*AllTopicsResp, error)
	GetTopicInfo(ctx context.Context, in *TopicReq, opts ...grpc.CallOption) (*TopicInfo, error)
	GetTopicStat(ctx context.Context, in *TopicReq, opts ...grpc.CallOption) (*TopicStat, error)
	GetTopicPermission(ctx context.Context, in *TopicPermissionReq, opts ...grpc.CallOption) (*TopicPermissionInfo, error)
	GetTopicMemberRole(ctx context.Context, in *TopicMemberRoleReq, opts ...grpc.CallOption) (*MemberRoleReply, error)
	GetTopicMeta(ctx context.Context, in *TopicMetaReq, opts ...grpc.CallOption) (*TopicMetaInfo, error)
	GetUserTopicsPaged(ctx context.Context, in *UserTopicsReq, opts ...grpc.CallOption) (*UserTopicsResp, error)
	GetBelongsTopicIDs(ctx context.Context, in *AidReq, opts ...grpc.CallOption) (*IDsResp, error)
	GetTopicMemberIDs(ctx context.Context, in *TopicReq, opts ...grpc.CallOption) (*IDsResp, error)
}

type topicClient struct {
	cc *grpc.ClientConn
}

func NewTopicClient(cc *grpc.ClientConn) TopicClient {
	return &topicClient{cc}
}

func (c *topicClient) CreateTopic(ctx context.Context, in *ArgCreateTopic, opts ...grpc.CallOption) (*IDResp, error) {
	out := new(IDResp)
	err := c.cc.Invoke(ctx, "/service.topic.Topic/CreateTopic", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topicClient) UpdateTopic(ctx context.Context, in *ArgUpdateTopic, opts ...grpc.CallOption) (*EmptyStruct, error) {
	out := new(EmptyStruct)
	err := c.cc.Invoke(ctx, "/service.topic.Topic/UpdateTopic", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topicClient) DelTopic(ctx context.Context, in *IDReq, opts ...grpc.CallOption) (*EmptyStruct, error) {
	out := new(EmptyStruct)
	err := c.cc.Invoke(ctx, "/service.topic.Topic/DelTopic", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topicClient) GetTopicResp(ctx context.Context, in *IDReq, opts ...grpc.CallOption) (*TopicResp, error) {
	out := new(TopicResp)
	err := c.cc.Invoke(ctx, "/service.topic.Topic/GetTopicResp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topicClient) ChangeOwner(ctx context.Context, in *ArgChangeOwner, opts ...grpc.CallOption) (*EmptyStruct, error) {
	out := new(EmptyStruct)
	err := c.cc.Invoke(ctx, "/service.topic.Topic/ChangeOwner", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topicClient) SaveAuthTopics(ctx context.Context, in *ArgSaveAuthTopics, opts ...grpc.CallOption) (*EmptyStruct, error) {
	out := new(EmptyStruct)
	err := c.cc.Invoke(ctx, "/service.topic.Topic/SaveAuthTopics", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topicClient) GetAuthTopics(ctx context.Context, in *IDReq, opts ...grpc.CallOption) (*AuthTopicsResp, error) {
	out := new(AuthTopicsResp)
	err := c.cc.Invoke(ctx, "/service.topic.Topic/GetAuthTopics", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topicClient) GetCatalogsHierarchy(ctx context.Context, in *IDReq, opts ...grpc.CallOption) (*CatalogsResp, error) {
	out := new(CatalogsResp)
	err := c.cc.Invoke(ctx, "/service.topic.Topic/GetCatalogsHierarchy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topicClient) GetCatalogTaxonomiesHierarchy(ctx context.Context, in *IDReq, opts ...grpc.CallOption) (*CatalogsResp, error) {
	out := new(CatalogsResp)
	err := c.cc.Invoke(ctx, "/service.topic.Topic/GetCatalogTaxonomiesHierarchy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topicClient) SaveCatalogs(ctx context.Context, in *ArgSaveCatalogs, opts ...grpc.CallOption) (*EmptyStruct, error) {
	out := new(EmptyStruct)
	err := c.cc.Invoke(ctx, "/service.topic.Topic/SaveCatalogs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topicClient) FollowTopic(ctx context.Context, in *ArgTopicFollow, opts ...grpc.CallOption) (*StatusResp, error) {
	out := new(StatusResp)
	err := c.cc.Invoke(ctx, "/service.topic.Topic/FollowTopic", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topicClient) AuditFollow(ctx context.Context, in *ArgAuditFollow, opts ...grpc.CallOption) (*EmptyStruct, error) {
	out := new(EmptyStruct)
	err := c.cc.Invoke(ctx, "/service.topic.Topic/AuditFollow", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topicClient) GetUserCanEditTopicIDs(ctx context.Context, in *AidReq, opts ...grpc.CallOption) (*IDsResp, error) {
	out := new(IDsResp)
	err := c.cc.Invoke(ctx, "/service.topic.Topic/GetUserCanEditTopicIDs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topicClient) GetFollowedTopicsIDs(ctx context.Context, in *AidReq, opts ...grpc.CallOption) (*IDsResp, error) {
	out := new(IDsResp)
	err := c.cc.Invoke(ctx, "/service.topic.Topic/GetFollowedTopicsIDs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topicClient) HasTaxonomy(ctx context.Context, in *TopicReq, opts ...grpc.CallOption) (*BoolResp, error) {
	out := new(BoolResp)
	err := c.cc.Invoke(ctx, "/service.topic.Topic/HasTaxonomy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topicClient) IsTopicMember(ctx context.Context, in *ArgIsTopicMember, opts ...grpc.CallOption) (*BoolResp, error) {
	out := new(BoolResp)
	err := c.cc.Invoke(ctx, "/service.topic.Topic/IsTopicMember", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topicClient) Invite(ctx context.Context, in *ArgTopicInvite, opts ...grpc.CallOption) (*EmptyStruct, error) {
	out := new(EmptyStruct)
	err := c.cc.Invoke(ctx, "/service.topic.Topic/Invite", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topicClient) ProcessInvite(ctx context.Context, in *ArgProcessInvite, opts ...grpc.CallOption) (*EmptyStruct, error) {
	out := new(EmptyStruct)
	err := c.cc.Invoke(ctx, "/service.topic.Topic/ProcessInvite", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topicClient) HasInvite(ctx context.Context, in *ArgHasInvite, opts ...grpc.CallOption) (*BoolResp, error) {
	out := new(BoolResp)
	err := c.cc.Invoke(ctx, "/service.topic.Topic/HasInvite", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topicClient) GetAllTopics(ctx context.Context, in *EmptyStruct, opts ...grpc.CallOption) (*AllTopicsResp, error) {
	out := new(AllTopicsResp)
	err := c.cc.Invoke(ctx, "/service.topic.Topic/GetAllTopics", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topicClient) GetTopicInfo(ctx context.Context, in *TopicReq, opts ...grpc.CallOption) (*TopicInfo, error) {
	out := new(TopicInfo)
	err := c.cc.Invoke(ctx, "/service.topic.Topic/GetTopicInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topicClient) GetTopicStat(ctx context.Context, in *TopicReq, opts ...grpc.CallOption) (*TopicStat, error) {
	out := new(TopicStat)
	err := c.cc.Invoke(ctx, "/service.topic.Topic/GetTopicStat", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topicClient) GetTopicPermission(ctx context.Context, in *TopicPermissionReq, opts ...grpc.CallOption) (*TopicPermissionInfo, error) {
	out := new(TopicPermissionInfo)
	err := c.cc.Invoke(ctx, "/service.topic.Topic/GetTopicPermission", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topicClient) GetTopicMemberRole(ctx context.Context, in *TopicMemberRoleReq, opts ...grpc.CallOption) (*MemberRoleReply, error) {
	out := new(MemberRoleReply)
	err := c.cc.Invoke(ctx, "/service.topic.Topic/GetTopicMemberRole", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topicClient) GetTopicMeta(ctx context.Context, in *TopicMetaReq, opts ...grpc.CallOption) (*TopicMetaInfo, error) {
	out := new(TopicMetaInfo)
	err := c.cc.Invoke(ctx, "/service.topic.Topic/GetTopicMeta", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topicClient) GetUserTopicsPaged(ctx context.Context, in *UserTopicsReq, opts ...grpc.CallOption) (*UserTopicsResp, error) {
	out := new(UserTopicsResp)
	err := c.cc.Invoke(ctx, "/service.topic.Topic/GetUserTopicsPaged", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topicClient) GetBelongsTopicIDs(ctx context.Context, in *AidReq, opts ...grpc.CallOption) (*IDsResp, error) {
	out := new(IDsResp)
	err := c.cc.Invoke(ctx, "/service.topic.Topic/GetBelongsTopicIDs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topicClient) GetTopicMemberIDs(ctx context.Context, in *TopicReq, opts ...grpc.CallOption) (*IDsResp, error) {
	out := new(IDsResp)
	err := c.cc.Invoke(ctx, "/service.topic.Topic/GetTopicMemberIDs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TopicServer is the server API for Topic service.
type TopicServer interface {
	CreateTopic(context.Context, *ArgCreateTopic) (*IDResp, error)
	UpdateTopic(context.Context, *ArgUpdateTopic) (*EmptyStruct, error)
	DelTopic(context.Context, *IDReq) (*EmptyStruct, error)
	GetTopicResp(context.Context, *IDReq) (*TopicResp, error)
	ChangeOwner(context.Context, *ArgChangeOwner) (*EmptyStruct, error)
	SaveAuthTopics(context.Context, *ArgSaveAuthTopics) (*EmptyStruct, error)
	GetAuthTopics(context.Context, *IDReq) (*AuthTopicsResp, error)
	GetCatalogsHierarchy(context.Context, *IDReq) (*CatalogsResp, error)
	GetCatalogTaxonomiesHierarchy(context.Context, *IDReq) (*CatalogsResp, error)
	SaveCatalogs(context.Context, *ArgSaveCatalogs) (*EmptyStruct, error)
	FollowTopic(context.Context, *ArgTopicFollow) (*StatusResp, error)
	AuditFollow(context.Context, *ArgAuditFollow) (*EmptyStruct, error)
	GetUserCanEditTopicIDs(context.Context, *AidReq) (*IDsResp, error)
	GetFollowedTopicsIDs(context.Context, *AidReq) (*IDsResp, error)
	HasTaxonomy(context.Context, *TopicReq) (*BoolResp, error)
	IsTopicMember(context.Context, *ArgIsTopicMember) (*BoolResp, error)
	Invite(context.Context, *ArgTopicInvite) (*EmptyStruct, error)
	ProcessInvite(context.Context, *ArgProcessInvite) (*EmptyStruct, error)
	HasInvite(context.Context, *ArgHasInvite) (*BoolResp, error)
	GetAllTopics(context.Context, *EmptyStruct) (*AllTopicsResp, error)
	GetTopicInfo(context.Context, *TopicReq) (*TopicInfo, error)
	GetTopicStat(context.Context, *TopicReq) (*TopicStat, error)
	GetTopicPermission(context.Context, *TopicPermissionReq) (*TopicPermissionInfo, error)
	GetTopicMemberRole(context.Context, *TopicMemberRoleReq) (*MemberRoleReply, error)
	GetTopicMeta(context.Context, *TopicMetaReq) (*TopicMetaInfo, error)
	GetUserTopicsPaged(context.Context, *UserTopicsReq) (*UserTopicsResp, error)
	GetBelongsTopicIDs(context.Context, *AidReq) (*IDsResp, error)
	GetTopicMemberIDs(context.Context, *TopicReq) (*IDsResp, error)
}

// UnimplementedTopicServer can be embedded to have forward compatible implementations.
type UnimplementedTopicServer struct {
}

func (*UnimplementedTopicServer) CreateTopic(ctx context.Context, req *ArgCreateTopic) (*IDResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTopic not implemented")
}
func (*UnimplementedTopicServer) UpdateTopic(ctx context.Context, req *ArgUpdateTopic) (*EmptyStruct, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTopic not implemented")
}
func (*UnimplementedTopicServer) DelTopic(ctx context.Context, req *IDReq) (*EmptyStruct, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DelTopic not implemented")
}
func (*UnimplementedTopicServer) GetTopicResp(ctx context.Context, req *IDReq) (*TopicResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTopicResp not implemented")
}
func (*UnimplementedTopicServer) ChangeOwner(ctx context.Context, req *ArgChangeOwner) (*EmptyStruct, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChangeOwner not implemented")
}
func (*UnimplementedTopicServer) SaveAuthTopics(ctx context.Context, req *ArgSaveAuthTopics) (*EmptyStruct, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SaveAuthTopics not implemented")
}
func (*UnimplementedTopicServer) GetAuthTopics(ctx context.Context, req *IDReq) (*AuthTopicsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAuthTopics not implemented")
}
func (*UnimplementedTopicServer) GetCatalogsHierarchy(ctx context.Context, req *IDReq) (*CatalogsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCatalogsHierarchy not implemented")
}
func (*UnimplementedTopicServer) GetCatalogTaxonomiesHierarchy(ctx context.Context, req *IDReq) (*CatalogsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCatalogTaxonomiesHierarchy not implemented")
}
func (*UnimplementedTopicServer) SaveCatalogs(ctx context.Context, req *ArgSaveCatalogs) (*EmptyStruct, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SaveCatalogs not implemented")
}
func (*UnimplementedTopicServer) FollowTopic(ctx context.Context, req *ArgTopicFollow) (*StatusResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FollowTopic not implemented")
}
func (*UnimplementedTopicServer) AuditFollow(ctx context.Context, req *ArgAuditFollow) (*EmptyStruct, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuditFollow not implemented")
}
func (*UnimplementedTopicServer) GetUserCanEditTopicIDs(ctx context.Context, req *AidReq) (*IDsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserCanEditTopicIDs not implemented")
}
func (*UnimplementedTopicServer) GetFollowedTopicsIDs(ctx context.Context, req *AidReq) (*IDsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFollowedTopicsIDs not implemented")
}
func (*UnimplementedTopicServer) HasTaxonomy(ctx context.Context, req *TopicReq) (*BoolResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HasTaxonomy not implemented")
}
func (*UnimplementedTopicServer) IsTopicMember(ctx context.Context, req *ArgIsTopicMember) (*BoolResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsTopicMember not implemented")
}
func (*UnimplementedTopicServer) Invite(ctx context.Context, req *ArgTopicInvite) (*EmptyStruct, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Invite not implemented")
}
func (*UnimplementedTopicServer) ProcessInvite(ctx context.Context, req *ArgProcessInvite) (*EmptyStruct, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProcessInvite not implemented")
}
func (*UnimplementedTopicServer) HasInvite(ctx context.Context, req *ArgHasInvite) (*BoolResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HasInvite not implemented")
}
func (*UnimplementedTopicServer) GetAllTopics(ctx context.Context, req *EmptyStruct) (*AllTopicsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllTopics not implemented")
}
func (*UnimplementedTopicServer) GetTopicInfo(ctx context.Context, req *TopicReq) (*TopicInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTopicInfo not implemented")
}
func (*UnimplementedTopicServer) GetTopicStat(ctx context.Context, req *TopicReq) (*TopicStat, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTopicStat not implemented")
}
func (*UnimplementedTopicServer) GetTopicPermission(ctx context.Context, req *TopicPermissionReq) (*TopicPermissionInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTopicPermission not implemented")
}
func (*UnimplementedTopicServer) GetTopicMemberRole(ctx context.Context, req *TopicMemberRoleReq) (*MemberRoleReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTopicMemberRole not implemented")
}
func (*UnimplementedTopicServer) GetTopicMeta(ctx context.Context, req *TopicMetaReq) (*TopicMetaInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTopicMeta not implemented")
}
func (*UnimplementedTopicServer) GetUserTopicsPaged(ctx context.Context, req *UserTopicsReq) (*UserTopicsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserTopicsPaged not implemented")
}
func (*UnimplementedTopicServer) GetBelongsTopicIDs(ctx context.Context, req *AidReq) (*IDsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBelongsTopicIDs not implemented")
}
func (*UnimplementedTopicServer) GetTopicMemberIDs(ctx context.Context, req *TopicReq) (*IDsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTopicMemberIDs not implemented")
}

func RegisterTopicServer(s *grpc.Server, srv TopicServer) {
	s.RegisterService(&_Topic_serviceDesc, srv)
}

func _Topic_CreateTopic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArgCreateTopic)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopicServer).CreateTopic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.topic.Topic/CreateTopic",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopicServer).CreateTopic(ctx, req.(*ArgCreateTopic))
	}
	return interceptor(ctx, in, info, handler)
}

func _Topic_UpdateTopic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArgUpdateTopic)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopicServer).UpdateTopic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.topic.Topic/UpdateTopic",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopicServer).UpdateTopic(ctx, req.(*ArgUpdateTopic))
	}
	return interceptor(ctx, in, info, handler)
}

func _Topic_DelTopic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopicServer).DelTopic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.topic.Topic/DelTopic",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopicServer).DelTopic(ctx, req.(*IDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Topic_GetTopicResp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopicServer).GetTopicResp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.topic.Topic/GetTopicResp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopicServer).GetTopicResp(ctx, req.(*IDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Topic_ChangeOwner_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArgChangeOwner)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopicServer).ChangeOwner(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.topic.Topic/ChangeOwner",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopicServer).ChangeOwner(ctx, req.(*ArgChangeOwner))
	}
	return interceptor(ctx, in, info, handler)
}

func _Topic_SaveAuthTopics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArgSaveAuthTopics)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopicServer).SaveAuthTopics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.topic.Topic/SaveAuthTopics",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopicServer).SaveAuthTopics(ctx, req.(*ArgSaveAuthTopics))
	}
	return interceptor(ctx, in, info, handler)
}

func _Topic_GetAuthTopics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopicServer).GetAuthTopics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.topic.Topic/GetAuthTopics",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopicServer).GetAuthTopics(ctx, req.(*IDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Topic_GetCatalogsHierarchy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopicServer).GetCatalogsHierarchy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.topic.Topic/GetCatalogsHierarchy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopicServer).GetCatalogsHierarchy(ctx, req.(*IDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Topic_GetCatalogTaxonomiesHierarchy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopicServer).GetCatalogTaxonomiesHierarchy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.topic.Topic/GetCatalogTaxonomiesHierarchy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopicServer).GetCatalogTaxonomiesHierarchy(ctx, req.(*IDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Topic_SaveCatalogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArgSaveCatalogs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopicServer).SaveCatalogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.topic.Topic/SaveCatalogs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopicServer).SaveCatalogs(ctx, req.(*ArgSaveCatalogs))
	}
	return interceptor(ctx, in, info, handler)
}

func _Topic_FollowTopic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArgTopicFollow)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopicServer).FollowTopic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.topic.Topic/FollowTopic",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopicServer).FollowTopic(ctx, req.(*ArgTopicFollow))
	}
	return interceptor(ctx, in, info, handler)
}

func _Topic_AuditFollow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArgAuditFollow)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopicServer).AuditFollow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.topic.Topic/AuditFollow",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopicServer).AuditFollow(ctx, req.(*ArgAuditFollow))
	}
	return interceptor(ctx, in, info, handler)
}

func _Topic_GetUserCanEditTopicIDs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AidReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopicServer).GetUserCanEditTopicIDs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.topic.Topic/GetUserCanEditTopicIDs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopicServer).GetUserCanEditTopicIDs(ctx, req.(*AidReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Topic_GetFollowedTopicsIDs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AidReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopicServer).GetFollowedTopicsIDs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.topic.Topic/GetFollowedTopicsIDs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopicServer).GetFollowedTopicsIDs(ctx, req.(*AidReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Topic_HasTaxonomy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TopicReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopicServer).HasTaxonomy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.topic.Topic/HasTaxonomy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopicServer).HasTaxonomy(ctx, req.(*TopicReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Topic_IsTopicMember_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArgIsTopicMember)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopicServer).IsTopicMember(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.topic.Topic/IsTopicMember",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopicServer).IsTopicMember(ctx, req.(*ArgIsTopicMember))
	}
	return interceptor(ctx, in, info, handler)
}

func _Topic_Invite_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArgTopicInvite)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopicServer).Invite(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.topic.Topic/Invite",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopicServer).Invite(ctx, req.(*ArgTopicInvite))
	}
	return interceptor(ctx, in, info, handler)
}

func _Topic_ProcessInvite_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArgProcessInvite)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopicServer).ProcessInvite(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.topic.Topic/ProcessInvite",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopicServer).ProcessInvite(ctx, req.(*ArgProcessInvite))
	}
	return interceptor(ctx, in, info, handler)
}

func _Topic_HasInvite_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArgHasInvite)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopicServer).HasInvite(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.topic.Topic/HasInvite",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopicServer).HasInvite(ctx, req.(*ArgHasInvite))
	}
	return interceptor(ctx, in, info, handler)
}

func _Topic_GetAllTopics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyStruct)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopicServer).GetAllTopics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.topic.Topic/GetAllTopics",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopicServer).GetAllTopics(ctx, req.(*EmptyStruct))
	}
	return interceptor(ctx, in, info, handler)
}

func _Topic_GetTopicInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TopicReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopicServer).GetTopicInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.topic.Topic/GetTopicInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopicServer).GetTopicInfo(ctx, req.(*TopicReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Topic_GetTopicStat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TopicReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopicServer).GetTopicStat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.topic.Topic/GetTopicStat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopicServer).GetTopicStat(ctx, req.(*TopicReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Topic_GetTopicPermission_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TopicPermissionReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopicServer).GetTopicPermission(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.topic.Topic/GetTopicPermission",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopicServer).GetTopicPermission(ctx, req.(*TopicPermissionReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Topic_GetTopicMemberRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TopicMemberRoleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopicServer).GetTopicMemberRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.topic.Topic/GetTopicMemberRole",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopicServer).GetTopicMemberRole(ctx, req.(*TopicMemberRoleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Topic_GetTopicMeta_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TopicMetaReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopicServer).GetTopicMeta(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.topic.Topic/GetTopicMeta",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopicServer).GetTopicMeta(ctx, req.(*TopicMetaReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Topic_GetUserTopicsPaged_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserTopicsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopicServer).GetUserTopicsPaged(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.topic.Topic/GetUserTopicsPaged",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopicServer).GetUserTopicsPaged(ctx, req.(*UserTopicsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Topic_GetBelongsTopicIDs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AidReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopicServer).GetBelongsTopicIDs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.topic.Topic/GetBelongsTopicIDs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopicServer).GetBelongsTopicIDs(ctx, req.(*AidReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Topic_GetTopicMemberIDs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TopicReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopicServer).GetTopicMemberIDs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.topic.Topic/GetTopicMemberIDs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopicServer).GetTopicMemberIDs(ctx, req.(*TopicReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _Topic_serviceDesc = grpc.ServiceDesc{
	ServiceName: "service.topic.Topic",
	HandlerType: (*TopicServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateTopic",
			Handler:    _Topic_CreateTopic_Handler,
		},
		{
			MethodName: "UpdateTopic",
			Handler:    _Topic_UpdateTopic_Handler,
		},
		{
			MethodName: "DelTopic",
			Handler:    _Topic_DelTopic_Handler,
		},
		{
			MethodName: "GetTopicResp",
			Handler:    _Topic_GetTopicResp_Handler,
		},
		{
			MethodName: "ChangeOwner",
			Handler:    _Topic_ChangeOwner_Handler,
		},
		{
			MethodName: "SaveAuthTopics",
			Handler:    _Topic_SaveAuthTopics_Handler,
		},
		{
			MethodName: "GetAuthTopics",
			Handler:    _Topic_GetAuthTopics_Handler,
		},
		{
			MethodName: "GetCatalogsHierarchy",
			Handler:    _Topic_GetCatalogsHierarchy_Handler,
		},
		{
			MethodName: "GetCatalogTaxonomiesHierarchy",
			Handler:    _Topic_GetCatalogTaxonomiesHierarchy_Handler,
		},
		{
			MethodName: "SaveCatalogs",
			Handler:    _Topic_SaveCatalogs_Handler,
		},
		{
			MethodName: "FollowTopic",
			Handler:    _Topic_FollowTopic_Handler,
		},
		{
			MethodName: "AuditFollow",
			Handler:    _Topic_AuditFollow_Handler,
		},
		{
			MethodName: "GetUserCanEditTopicIDs",
			Handler:    _Topic_GetUserCanEditTopicIDs_Handler,
		},
		{
			MethodName: "GetFollowedTopicsIDs",
			Handler:    _Topic_GetFollowedTopicsIDs_Handler,
		},
		{
			MethodName: "HasTaxonomy",
			Handler:    _Topic_HasTaxonomy_Handler,
		},
		{
			MethodName: "IsTopicMember",
			Handler:    _Topic_IsTopicMember_Handler,
		},
		{
			MethodName: "Invite",
			Handler:    _Topic_Invite_Handler,
		},
		{
			MethodName: "ProcessInvite",
			Handler:    _Topic_ProcessInvite_Handler,
		},
		{
			MethodName: "HasInvite",
			Handler:    _Topic_HasInvite_Handler,
		},
		{
			MethodName: "GetAllTopics",
			Handler:    _Topic_GetAllTopics_Handler,
		},
		{
			MethodName: "GetTopicInfo",
			Handler:    _Topic_GetTopicInfo_Handler,
		},
		{
			MethodName: "GetTopicStat",
			Handler:    _Topic_GetTopicStat_Handler,
		},
		{
			MethodName: "GetTopicPermission",
			Handler:    _Topic_GetTopicPermission_Handler,
		},
		{
			MethodName: "GetTopicMemberRole",
			Handler:    _Topic_GetTopicMemberRole_Handler,
		},
		{
			MethodName: "GetTopicMeta",
			Handler:    _Topic_GetTopicMeta_Handler,
		},
		{
			MethodName: "GetUserTopicsPaged",
			Handler:    _Topic_GetUserTopicsPaged_Handler,
		},
		{
			MethodName: "GetBelongsTopicIDs",
			Handler:    _Topic_GetBelongsTopicIDs_Handler,
		},
		{
			MethodName: "GetTopicMemberIDs",
			Handler:    _Topic_GetTopicMemberIDs_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pb.proto",
}

func (m *EmptyStruct) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EmptyStruct) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EmptyStruct) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *MemberRoleReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemberRoleReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MemberRoleReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Role) > 0 {
		i -= len(m.Role)
		copy(dAtA[i:], m.Role)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Role)))
		i--
		dAtA[i] = 0x12
	}
	if m.IsMember {
		i--
		if m.IsMember {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Creator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Creator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Creator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Introduction) > 0 {
		i -= len(m.Introduction)
		copy(dAtA[i:], m.Introduction)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Introduction)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Avatar) > 0 {
		i -= len(m.Avatar)
		copy(dAtA[i:], m.Avatar)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Avatar)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.UserName) > 0 {
		i -= len(m.UserName)
		copy(dAtA[i:], m.UserName)
		i = encodeVarintPb(dAtA, i, uint64(len(m.UserName)))
		i--
		dAtA[i] = 0x12
	}
	if m.ID != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TopicInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopicInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TopicInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Stat != nil {
		{
			size, err := m.Stat.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.UpdatedAt != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.UpdatedAt))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.CreatedAt != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.CreatedAt))
		i--
		dAtA[i] = 0x78
	}
	if m.Creator != nil {
		{
			size, err := m.Creator.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if len(m.TopicHome) > 0 {
		i -= len(m.TopicHome)
		copy(dAtA[i:], m.TopicHome)
		i = encodeVarintPb(dAtA, i, uint64(len(m.TopicHome)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.CatalogViewType) > 0 {
		i -= len(m.CatalogViewType)
		copy(dAtA[i:], m.CatalogViewType)
		i = encodeVarintPb(dAtA, i, uint64(len(m.CatalogViewType)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.JoinPermission) > 0 {
		i -= len(m.JoinPermission)
		copy(dAtA[i:], m.JoinPermission)
		i = encodeVarintPb(dAtA, i, uint64(len(m.JoinPermission)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.EditPermission) > 0 {
		i -= len(m.EditPermission)
		copy(dAtA[i:], m.EditPermission)
		i = encodeVarintPb(dAtA, i, uint64(len(m.EditPermission)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.ViewPermission) > 0 {
		i -= len(m.ViewPermission)
		copy(dAtA[i:], m.ViewPermission)
		i = encodeVarintPb(dAtA, i, uint64(len(m.ViewPermission)))
		i--
		dAtA[i] = 0x4a
	}
	if m.IsPrivate {
		i--
		if m.IsPrivate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.AllowChat {
		i--
		if m.AllowChat {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.AllowDiscuss {
		i--
		if m.AllowDiscuss {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.Introduction) > 0 {
		i -= len(m.Introduction)
		copy(dAtA[i:], m.Introduction)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Introduction)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Bg) > 0 {
		i -= len(m.Bg)
		copy(dAtA[i:], m.Bg)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Bg)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Avatar) > 0 {
		i -= len(m.Avatar)
		copy(dAtA[i:], m.Avatar)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Avatar)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.ID != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TopicRootCatalogInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopicRootCatalogInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TopicRootCatalogInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Children) > 0 {
		for iNdEx := len(m.Children) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Children[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.Article != nil {
		{
			size, err := m.Article.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.RefID != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.RefID))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x22
	}
	if m.Seq != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Seq))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.ID != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TopicParentCatalogInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopicParentCatalogInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TopicParentCatalogInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Children) > 0 {
		for iNdEx := len(m.Children) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Children[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.Article != nil {
		{
			size, err := m.Article.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.RefID != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.RefID))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x22
	}
	if m.Seq != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Seq))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.ID != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TopicChildCatalogInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopicChildCatalogInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TopicChildCatalogInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Article != nil {
		{
			size, err := m.Article.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.RefID != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.RefID))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x22
	}
	if m.Seq != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Seq))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.ID != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TargetArticle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TargetArticle) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TargetArticle) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Creator != nil {
		{
			size, err := m.Creator.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.UpdatedAt != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.UpdatedAt))
		i--
		dAtA[i] = 0x50
	}
	if m.CreatedAt != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.CreatedAt))
		i--
		dAtA[i] = 0x48
	}
	if m.CommentCount != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.CommentCount))
		i--
		dAtA[i] = 0x40
	}
	if m.ReviseCount != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.ReviseCount))
		i--
		dAtA[i] = 0x38
	}
	if m.DislikeCount != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.DislikeCount))
		i--
		dAtA[i] = 0x30
	}
	if m.LikeCount != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.LikeCount))
		i--
		dAtA[i] = 0x28
	}
	if len(m.ImageUrls) > 0 {
		for iNdEx := len(m.ImageUrls) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ImageUrls[iNdEx])
			copy(dAtA[i:], m.ImageUrls[iNdEx])
			i = encodeVarintPb(dAtA, i, uint64(len(m.ImageUrls[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Excerpt) > 0 {
		i -= len(m.Excerpt)
		copy(dAtA[i:], m.Excerpt)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Excerpt)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0x12
	}
	if m.ID != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TopicStat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopicStat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TopicStat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DiscussionCount != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.DiscussionCount))
		i--
		dAtA[i] = 0x18
	}
	if m.ArticleCount != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.ArticleCount))
		i--
		dAtA[i] = 0x10
	}
	if m.MemberCount != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.MemberCount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TopicMetaInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopicMetaInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TopicMetaInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.MemberRole) > 0 {
		i -= len(m.MemberRole)
		copy(dAtA[i:], m.MemberRole)
		i = encodeVarintPb(dAtA, i, uint64(len(m.MemberRole)))
		i--
		dAtA[i] = 0x3a
	}
	if m.IsMember {
		i--
		if m.IsMember {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.FollowStatus != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.FollowStatus))
		i--
		dAtA[i] = 0x28
	}
	if m.CanView {
		i--
		if m.CanView {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Fav {
		i--
		if m.Fav {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.CanEdit {
		i--
		if m.CanEdit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.CanFollow {
		i--
		if m.CanFollow {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TopicPermissionInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopicPermissionInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TopicPermissionInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.MemberRole) > 0 {
		i -= len(m.MemberRole)
		copy(dAtA[i:], m.MemberRole)
		i = encodeVarintPb(dAtA, i, uint64(len(m.MemberRole)))
		i--
		dAtA[i] = 0x1a
	}
	if m.IsMember {
		i--
		if m.IsMember {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.EditPermission) > 0 {
		i -= len(m.EditPermission)
		copy(dAtA[i:], m.EditPermission)
		i = encodeVarintPb(dAtA, i, uint64(len(m.EditPermission)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TopicReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopicReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TopicReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UseMaster {
		i--
		if m.UseMaster {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TopicMetaReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopicMetaReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TopicMetaReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UseMaster {
		i--
		if m.UseMaster {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.AccountID != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.AccountID))
		i--
		dAtA[i] = 0x10
	}
	if m.TopicID != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.TopicID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TopicMemberRoleReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopicMemberRoleReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TopicMemberRoleReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UseMaster {
		i--
		if m.UseMaster {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.AccountID != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.AccountID))
		i--
		dAtA[i] = 0x10
	}
	if m.TopicID != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.TopicID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TopicPermissionReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopicPermissionReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TopicPermissionReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UseMaster {
		i--
		if m.UseMaster {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.AccountID != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.AccountID))
		i--
		dAtA[i] = 0x10
	}
	if m.TopicID != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.TopicID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserTopicsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserTopicsReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserTopicsReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Offset != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x18
	}
	if m.Limit != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x10
	}
	if m.AccountID != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.AccountID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserTopicsResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserTopicsResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserTopicsResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AllTopicsResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllTopicsResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AllTopicsResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AidReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AidReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AidReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UseMaster {
		i--
		if m.UseMaster {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.AccountID != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.AccountID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IDsResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IDsResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IDsResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.IDs) > 0 {
		dAtA8 := make([]byte, len(m.IDs)*10)
		var j7 int
		for _, num1 := range m.IDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		i -= j7
		copy(dAtA[i:], dAtA8[:j7])
		i = encodeVarintPb(dAtA, i, uint64(j7))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IDReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IDReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IDReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Aid != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Aid))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Include) > 0 {
		i -= len(m.Include)
		copy(dAtA[i:], m.Include)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Include)))
		i--
		dAtA[i] = 0x12
	}
	if m.ID != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IDResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IDResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IDResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ID != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TopicResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopicResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TopicResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TopicMeta != nil {
		{
			size, err := m.TopicMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	if len(m.AuthTopics) > 0 {
		for iNdEx := len(m.AuthTopics) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AuthTopics[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xd2
		}
	}
	if len(m.DiscussCategories) > 0 {
		for iNdEx := len(m.DiscussCategories) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DiscussCategories[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xca
		}
	}
	if len(m.Catalogs) > 0 {
		for iNdEx := len(m.Catalogs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Catalogs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xc2
		}
	}
	if len(m.Members) > 0 {
		for iNdEx := len(m.Members) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Members[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xb2
		}
	}
	if m.HasCatalogTaxonomy {
		i--
		if m.HasCatalogTaxonomy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.Stat != nil {
		{
			size, err := m.Stat.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.Important {
		i--
		if m.Important {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.MuteNotification {
		i--
		if m.MuteNotification {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.UpdatedAt != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.UpdatedAt))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.CreatedAt != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.CreatedAt))
		i--
		dAtA[i] = 0x78
	}
	if m.Creator != nil {
		{
			size, err := m.Creator.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if len(m.TopicHome) > 0 {
		i -= len(m.TopicHome)
		copy(dAtA[i:], m.TopicHome)
		i = encodeVarintPb(dAtA, i, uint64(len(m.TopicHome)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.CatalogViewType) > 0 {
		i -= len(m.CatalogViewType)
		copy(dAtA[i:], m.CatalogViewType)
		i = encodeVarintPb(dAtA, i, uint64(len(m.CatalogViewType)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.JoinPermission) > 0 {
		i -= len(m.JoinPermission)
		copy(dAtA[i:], m.JoinPermission)
		i = encodeVarintPb(dAtA, i, uint64(len(m.JoinPermission)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.EditPermission) > 0 {
		i -= len(m.EditPermission)
		copy(dAtA[i:], m.EditPermission)
		i = encodeVarintPb(dAtA, i, uint64(len(m.EditPermission)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.ViewPermission) > 0 {
		i -= len(m.ViewPermission)
		copy(dAtA[i:], m.ViewPermission)
		i = encodeVarintPb(dAtA, i, uint64(len(m.ViewPermission)))
		i--
		dAtA[i] = 0x4a
	}
	if m.IsPrivate {
		i--
		if m.IsPrivate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.AllowChat {
		i--
		if m.AllowChat {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.AllowDiscuss {
		i--
		if m.AllowDiscuss {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.Introduction) > 0 {
		i -= len(m.Introduction)
		copy(dAtA[i:], m.Introduction)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Introduction)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Bg) > 0 {
		i -= len(m.Bg)
		copy(dAtA[i:], m.Bg)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Bg)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Avatar) > 0 {
		i -= len(m.Avatar)
		copy(dAtA[i:], m.Avatar)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Avatar)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.ID != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TopicMemberInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopicMemberInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TopicMemberInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UserName) > 0 {
		i -= len(m.UserName)
		copy(dAtA[i:], m.UserName)
		i = encodeVarintPb(dAtA, i, uint64(len(m.UserName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Avatar) > 0 {
		i -= len(m.Avatar)
		copy(dAtA[i:], m.Avatar)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Avatar)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Role) > 0 {
		i -= len(m.Role)
		copy(dAtA[i:], m.Role)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Role)))
		i--
		dAtA[i] = 0x12
	}
	if m.AccountID != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.AccountID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AuthTopicInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthTopicInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthTopicInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Avatar) > 0 {
		i -= len(m.Avatar)
		copy(dAtA[i:], m.Avatar)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Avatar)))
		i--
		dAtA[i] = 0x2a
	}
	if m.MemberCount != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.MemberCount))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Permission) > 0 {
		i -= len(m.Permission)
		copy(dAtA[i:], m.Permission)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Permission)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.EditPermission) > 0 {
		i -= len(m.EditPermission)
		copy(dAtA[i:], m.EditPermission)
		i = encodeVarintPb(dAtA, i, uint64(len(m.EditPermission)))
		i--
		dAtA[i] = 0x12
	}
	if m.ToTopicID != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.ToTopicID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DiscussCategoryInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiscussCategoryInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DiscussCategoryInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Seq != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Seq))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.TopicID != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.TopicID))
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ArgChangeOwner) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArgChangeOwner) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArgChangeOwner) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Aid != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Aid))
		i--
		dAtA[i] = 0x18
	}
	if m.ToAccountID != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.ToAccountID))
		i--
		dAtA[i] = 0x10
	}
	if m.TopicID != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.TopicID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ArgCreateTopic) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArgCreateTopic) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArgCreateTopic) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AllowChat {
		i--
		if m.AllowChat {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.AllowDiscuss {
		i--
		if m.AllowDiscuss {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.CatalogViewType) > 0 {
		i -= len(m.CatalogViewType)
		copy(dAtA[i:], m.CatalogViewType)
		i = encodeVarintPb(dAtA, i, uint64(len(m.CatalogViewType)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Introduction) > 0 {
		i -= len(m.Introduction)
		copy(dAtA[i:], m.Introduction)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Introduction)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x22
	}
	if m.Bg != nil {
		{
			size := m.Bg.Size()
			i -= size
			if _, err := m.Bg.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Avatar != nil {
		{
			size := m.Avatar.Size()
			i -= size
			if _, err := m.Avatar.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Aid != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Aid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ArgCreateTopic_AvatarValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArgCreateTopic_AvatarValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.AvatarValue)
	copy(dAtA[i:], m.AvatarValue)
	i = encodeVarintPb(dAtA, i, uint64(len(m.AvatarValue)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *ArgCreateTopic_BgValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArgCreateTopic_BgValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.BgValue)
	copy(dAtA[i:], m.BgValue)
	i = encodeVarintPb(dAtA, i, uint64(len(m.BgValue)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func (m *ArgUpdateTopic) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArgUpdateTopic) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArgUpdateTopic) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Aid != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Aid))
		i--
		dAtA[i] = 0x78
	}
	if m.MuteNotification != nil {
		{
			size := m.MuteNotification.Size()
			i -= size
			if _, err := m.MuteNotification.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Important != nil {
		{
			size := m.Important.Size()
			i -= size
			if _, err := m.Important.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.JoinPermission != nil {
		{
			size := m.JoinPermission.Size()
			i -= size
			if _, err := m.JoinPermission.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.EditPermission != nil {
		{
			size := m.EditPermission.Size()
			i -= size
			if _, err := m.EditPermission.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.ViewPermission != nil {
		{
			size := m.ViewPermission.Size()
			i -= size
			if _, err := m.ViewPermission.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.IsPrivate != nil {
		{
			size := m.IsPrivate.Size()
			i -= size
			if _, err := m.IsPrivate.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.AllowDiscuss != nil {
		{
			size := m.AllowDiscuss.Size()
			i -= size
			if _, err := m.AllowDiscuss.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.AllowChat != nil {
		{
			size := m.AllowChat.Size()
			i -= size
			if _, err := m.AllowChat.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.CatalogViewType != nil {
		{
			size := m.CatalogViewType.Size()
			i -= size
			if _, err := m.CatalogViewType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Introduction != nil {
		{
			size := m.Introduction.Size()
			i -= size
			if _, err := m.Introduction.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Name != nil {
		{
			size := m.Name.Size()
			i -= size
			if _, err := m.Name.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Bg != nil {
		{
			size := m.Bg.Size()
			i -= size
			if _, err := m.Bg.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Avatar != nil {
		{
			size := m.Avatar.Size()
			i -= size
			if _, err := m.Avatar.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.ID != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ArgUpdateTopic_AvatarValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArgUpdateTopic_AvatarValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.AvatarValue)
	copy(dAtA[i:], m.AvatarValue)
	i = encodeVarintPb(dAtA, i, uint64(len(m.AvatarValue)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *ArgUpdateTopic_BgValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArgUpdateTopic_BgValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.BgValue)
	copy(dAtA[i:], m.BgValue)
	i = encodeVarintPb(dAtA, i, uint64(len(m.BgValue)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func (m *ArgUpdateTopic_NameValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArgUpdateTopic_NameValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.NameValue)
	copy(dAtA[i:], m.NameValue)
	i = encodeVarintPb(dAtA, i, uint64(len(m.NameValue)))
	i--
	dAtA[i] = 0x22
	return len(dAtA) - i, nil
}
func (m *ArgUpdateTopic_IntroductionValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArgUpdateTopic_IntroductionValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.IntroductionValue)
	copy(dAtA[i:], m.IntroductionValue)
	i = encodeVarintPb(dAtA, i, uint64(len(m.IntroductionValue)))
	i--
	dAtA[i] = 0x2a
	return len(dAtA) - i, nil
}
func (m *ArgUpdateTopic_CatalogViewTypeValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArgUpdateTopic_CatalogViewTypeValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.CatalogViewTypeValue)
	copy(dAtA[i:], m.CatalogViewTypeValue)
	i = encodeVarintPb(dAtA, i, uint64(len(m.CatalogViewTypeValue)))
	i--
	dAtA[i] = 0x32
	return len(dAtA) - i, nil
}
func (m *ArgUpdateTopic_AllowChatValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArgUpdateTopic_AllowChatValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.AllowChatValue {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x38
	return len(dAtA) - i, nil
}
func (m *ArgUpdateTopic_AllowDiscussValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArgUpdateTopic_AllowDiscussValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.AllowDiscussValue {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x40
	return len(dAtA) - i, nil
}
func (m *ArgUpdateTopic_IsPrivateValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArgUpdateTopic_IsPrivateValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.IsPrivateValue {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x48
	return len(dAtA) - i, nil
}
func (m *ArgUpdateTopic_ViewPermissionValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArgUpdateTopic_ViewPermissionValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ViewPermissionValue)
	copy(dAtA[i:], m.ViewPermissionValue)
	i = encodeVarintPb(dAtA, i, uint64(len(m.ViewPermissionValue)))
	i--
	dAtA[i] = 0x52
	return len(dAtA) - i, nil
}
func (m *ArgUpdateTopic_EditPermissionValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArgUpdateTopic_EditPermissionValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.EditPermissionValue)
	copy(dAtA[i:], m.EditPermissionValue)
	i = encodeVarintPb(dAtA, i, uint64(len(m.EditPermissionValue)))
	i--
	dAtA[i] = 0x5a
	return len(dAtA) - i, nil
}
func (m *ArgUpdateTopic_JoinPermissionValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArgUpdateTopic_JoinPermissionValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.JoinPermissionValue)
	copy(dAtA[i:], m.JoinPermissionValue)
	i = encodeVarintPb(dAtA, i, uint64(len(m.JoinPermissionValue)))
	i--
	dAtA[i] = 0x62
	return len(dAtA) - i, nil
}
func (m *ArgUpdateTopic_ImportantValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArgUpdateTopic_ImportantValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.ImportantValue {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x68
	return len(dAtA) - i, nil
}
func (m *ArgUpdateTopic_MuteNotificationValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArgUpdateTopic_MuteNotificationValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.MuteNotificationValue {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x70
	return len(dAtA) - i, nil
}
func (m *TopicMembersPagedResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopicMembersPagedResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TopicMembersPagedResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		for iNdEx := len(m.Data) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Data[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.PageSize != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.PageSize))
		i--
		dAtA[i] = 0x10
	}
	if m.Count != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ArgBatchSavedTopicMember) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArgBatchSavedTopicMember) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArgBatchSavedTopicMember) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Aid != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Aid))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Members) > 0 {
		for iNdEx := len(m.Members) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Members[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.TopicID != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.TopicID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ArgTopicMember) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArgTopicMember) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArgTopicMember) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Opt) > 0 {
		i -= len(m.Opt)
		copy(dAtA[i:], m.Opt)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Opt)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Role) > 0 {
		i -= len(m.Role)
		copy(dAtA[i:], m.Role)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Role)))
		i--
		dAtA[i] = 0x12
	}
	if m.AccountID != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.AccountID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ArgTopicCatalog) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArgTopicCatalog) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArgTopicCatalog) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RefID != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.RefID))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x22
	}
	if m.Seq != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Seq))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.ID != nil {
		{
			size := m.ID.Size()
			i -= size
			if _, err := m.ID.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ArgTopicCatalog_IDValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArgTopicCatalog_IDValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPb(dAtA, i, uint64(m.IDValue))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}
func (m *ArgCanEditTopicsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArgCanEditTopicsReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArgCanEditTopicsReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Ps != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Ps))
		i--
		dAtA[i] = 0x10
	}
	if m.Pn != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Pn))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CanEditTopicsResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CanEditTopicsResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CanEditTopicsResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Paging != nil {
		{
			size, err := m.Paging.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CanEditTopicItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CanEditTopicItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CanEditTopicItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.HasCatalogTaxonomy {
		i--
		if m.HasCatalogTaxonomy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if len(m.EditPermission) > 0 {
		i -= len(m.EditPermission)
		copy(dAtA[i:], m.EditPermission)
		i = encodeVarintPb(dAtA, i, uint64(len(m.EditPermission)))
		i--
		dAtA[i] = 0x4a
	}
	if m.DiscussionCount != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.DiscussionCount))
		i--
		dAtA[i] = 0x40
	}
	if m.ArticleCount != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.ArticleCount))
		i--
		dAtA[i] = 0x38
	}
	if m.MemberCount != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.MemberCount))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Introduction) > 0 {
		i -= len(m.Introduction)
		copy(dAtA[i:], m.Introduction)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Introduction)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Avatar) > 0 {
		i -= len(m.Avatar)
		copy(dAtA[i:], m.Avatar)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Avatar)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.ID != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Paging) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Paging) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Paging) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Prev) > 0 {
		i -= len(m.Prev)
		copy(dAtA[i:], m.Prev)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Prev)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Next) > 0 {
		i -= len(m.Next)
		copy(dAtA[i:], m.Next)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Next)))
		i--
		dAtA[i] = 0x1a
	}
	if m.IsEnd {
		i--
		if m.IsEnd {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Total != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ArgSaveAuthTopics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArgSaveAuthTopics) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArgSaveAuthTopics) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Aid != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Aid))
		i--
		dAtA[i] = 0x18
	}
	if len(m.AuthTopics) > 0 {
		for iNdEx := len(m.AuthTopics) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AuthTopics[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.TopicID != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.TopicID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ArgAuthTopic) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArgAuthTopic) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArgAuthTopic) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Permission) > 0 {
		i -= len(m.Permission)
		copy(dAtA[i:], m.Permission)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Permission)))
		i--
		dAtA[i] = 0x12
	}
	if m.TopicID != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.TopicID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AuthTopicsResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthTopicsResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthTopicsResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CatalogsResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CatalogsResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CatalogsResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ArgSaveCatalogs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArgSaveCatalogs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArgSaveCatalogs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.ParentID != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.ParentID))
		i--
		dAtA[i] = 0x18
	}
	if m.Aid != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Aid))
		i--
		dAtA[i] = 0x10
	}
	if m.TopicID != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.TopicID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ArgTopicFollow) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArgTopicFollow) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArgTopicFollow) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Aid != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Aid))
		i--
		dAtA[i] = 0x20
	}
	if m.AllowViewCert {
		i--
		if m.AllowViewCert {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x12
	}
	if m.TopicID != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.TopicID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ArgAuditFollow) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArgAuditFollow) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArgAuditFollow) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Aid != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Aid))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Approve {
		i--
		if m.Approve {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StatusResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatusResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatusResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Status != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ArgTopicInvite) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArgTopicInvite) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArgTopicInvite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Aid != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Aid))
		i--
		dAtA[i] = 0x18
	}
	if m.AccountID != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.AccountID))
		i--
		dAtA[i] = 0x10
	}
	if m.TopicID != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.TopicID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ArgProcessInvite) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArgProcessInvite) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArgProcessInvite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Aid != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Aid))
		i--
		dAtA[i] = 0x18
	}
	if m.Result {
		i--
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BoolResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BoolResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BoolResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Result {
		i--
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ArgIsTopicMember) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArgIsTopicMember) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArgIsTopicMember) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TopicID != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.TopicID))
		i--
		dAtA[i] = 0x10
	}
	if m.AccountID != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.AccountID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ArgHasInvite) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArgHasInvite) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArgHasInvite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TopicID != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.TopicID))
		i--
		dAtA[i] = 0x10
	}
	if m.AccountID != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.AccountID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintPb(dAtA []byte, offset int, v uint64) int {
	offset -= sovPb(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *EmptyStruct) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MemberRoleReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsMember {
		n += 2
	}
	l = len(m.Role)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Creator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovPb(uint64(m.ID))
	}
	l = len(m.UserName)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Avatar)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Introduction)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TopicInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovPb(uint64(m.ID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Avatar)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Bg)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Introduction)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.AllowDiscuss {
		n += 2
	}
	if m.AllowChat {
		n += 2
	}
	if m.IsPrivate {
		n += 2
	}
	l = len(m.ViewPermission)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.EditPermission)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.JoinPermission)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.CatalogViewType)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.TopicHome)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Creator != nil {
		l = m.Creator.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if m.CreatedAt != 0 {
		n += 1 + sovPb(uint64(m.CreatedAt))
	}
	if m.UpdatedAt != 0 {
		n += 2 + sovPb(uint64(m.UpdatedAt))
	}
	if m.Stat != nil {
		l = m.Stat.Size()
		n += 2 + l + sovPb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TopicRootCatalogInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovPb(uint64(m.ID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Seq != 0 {
		n += 1 + sovPb(uint64(m.Seq))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.RefID != 0 {
		n += 1 + sovPb(uint64(m.RefID))
	}
	if m.Article != nil {
		l = m.Article.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if len(m.Children) > 0 {
		for _, e := range m.Children {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TopicParentCatalogInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovPb(uint64(m.ID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Seq != 0 {
		n += 1 + sovPb(uint64(m.Seq))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.RefID != 0 {
		n += 1 + sovPb(uint64(m.RefID))
	}
	if m.Article != nil {
		l = m.Article.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if len(m.Children) > 0 {
		for _, e := range m.Children {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TopicChildCatalogInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovPb(uint64(m.ID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Seq != 0 {
		n += 1 + sovPb(uint64(m.Seq))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.RefID != 0 {
		n += 1 + sovPb(uint64(m.RefID))
	}
	if m.Article != nil {
		l = m.Article.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TargetArticle) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovPb(uint64(m.ID))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Excerpt)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if len(m.ImageUrls) > 0 {
		for _, s := range m.ImageUrls {
			l = len(s)
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.LikeCount != 0 {
		n += 1 + sovPb(uint64(m.LikeCount))
	}
	if m.DislikeCount != 0 {
		n += 1 + sovPb(uint64(m.DislikeCount))
	}
	if m.ReviseCount != 0 {
		n += 1 + sovPb(uint64(m.ReviseCount))
	}
	if m.CommentCount != 0 {
		n += 1 + sovPb(uint64(m.CommentCount))
	}
	if m.CreatedAt != 0 {
		n += 1 + sovPb(uint64(m.CreatedAt))
	}
	if m.UpdatedAt != 0 {
		n += 1 + sovPb(uint64(m.UpdatedAt))
	}
	if m.Creator != nil {
		l = m.Creator.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TopicStat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MemberCount != 0 {
		n += 1 + sovPb(uint64(m.MemberCount))
	}
	if m.ArticleCount != 0 {
		n += 1 + sovPb(uint64(m.ArticleCount))
	}
	if m.DiscussionCount != 0 {
		n += 1 + sovPb(uint64(m.DiscussionCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TopicMetaInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CanFollow {
		n += 2
	}
	if m.CanEdit {
		n += 2
	}
	if m.Fav {
		n += 2
	}
	if m.CanView {
		n += 2
	}
	if m.FollowStatus != 0 {
		n += 1 + sovPb(uint64(m.FollowStatus))
	}
	if m.IsMember {
		n += 2
	}
	l = len(m.MemberRole)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TopicPermissionInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.EditPermission)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.IsMember {
		n += 2
	}
	l = len(m.MemberRole)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TopicReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovPb(uint64(m.ID))
	}
	if m.UseMaster {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TopicMetaReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TopicID != 0 {
		n += 1 + sovPb(uint64(m.TopicID))
	}
	if m.AccountID != 0 {
		n += 1 + sovPb(uint64(m.AccountID))
	}
	if m.UseMaster {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TopicMemberRoleReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TopicID != 0 {
		n += 1 + sovPb(uint64(m.TopicID))
	}
	if m.AccountID != 0 {
		n += 1 + sovPb(uint64(m.AccountID))
	}
	if m.UseMaster {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TopicPermissionReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TopicID != 0 {
		n += 1 + sovPb(uint64(m.TopicID))
	}
	if m.AccountID != 0 {
		n += 1 + sovPb(uint64(m.AccountID))
	}
	if m.UseMaster {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserTopicsReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AccountID != 0 {
		n += 1 + sovPb(uint64(m.AccountID))
	}
	if m.Limit != 0 {
		n += 1 + sovPb(uint64(m.Limit))
	}
	if m.Offset != 0 {
		n += 1 + sovPb(uint64(m.Offset))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserTopicsResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AllTopicsResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AidReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AccountID != 0 {
		n += 1 + sovPb(uint64(m.AccountID))
	}
	if m.UseMaster {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IDsResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.IDs) > 0 {
		l = 0
		for _, e := range m.IDs {
			l += sovPb(uint64(e))
		}
		n += 1 + sovPb(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IDReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovPb(uint64(m.ID))
	}
	l = len(m.Include)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Aid != 0 {
		n += 1 + sovPb(uint64(m.Aid))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IDResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovPb(uint64(m.ID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TopicResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovPb(uint64(m.ID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Avatar)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Bg)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Introduction)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.AllowDiscuss {
		n += 2
	}
	if m.AllowChat {
		n += 2
	}
	if m.IsPrivate {
		n += 2
	}
	l = len(m.ViewPermission)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.EditPermission)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.JoinPermission)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.CatalogViewType)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.TopicHome)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Creator != nil {
		l = m.Creator.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if m.CreatedAt != 0 {
		n += 1 + sovPb(uint64(m.CreatedAt))
	}
	if m.UpdatedAt != 0 {
		n += 2 + sovPb(uint64(m.UpdatedAt))
	}
	if m.MuteNotification {
		n += 3
	}
	if m.Important {
		n += 3
	}
	if m.Stat != nil {
		l = m.Stat.Size()
		n += 2 + l + sovPb(uint64(l))
	}
	if m.HasCatalogTaxonomy {
		n += 3
	}
	if len(m.Members) > 0 {
		for _, e := range m.Members {
			l = e.Size()
			n += 2 + l + sovPb(uint64(l))
		}
	}
	if len(m.Catalogs) > 0 {
		for _, e := range m.Catalogs {
			l = e.Size()
			n += 2 + l + sovPb(uint64(l))
		}
	}
	if len(m.DiscussCategories) > 0 {
		for _, e := range m.DiscussCategories {
			l = e.Size()
			n += 2 + l + sovPb(uint64(l))
		}
	}
	if len(m.AuthTopics) > 0 {
		for _, e := range m.AuthTopics {
			l = e.Size()
			n += 2 + l + sovPb(uint64(l))
		}
	}
	if m.TopicMeta != nil {
		l = m.TopicMeta.Size()
		n += 2 + l + sovPb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TopicMemberInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AccountID != 0 {
		n += 1 + sovPb(uint64(m.AccountID))
	}
	l = len(m.Role)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Avatar)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.UserName)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AuthTopicInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ToTopicID != 0 {
		n += 1 + sovPb(uint64(m.ToTopicID))
	}
	l = len(m.EditPermission)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Permission)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.MemberCount != 0 {
		n += 1 + sovPb(uint64(m.MemberCount))
	}
	l = len(m.Avatar)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DiscussCategoryInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovPb(uint64(m.ID))
	}
	if m.TopicID != 0 {
		n += 1 + sovPb(uint64(m.TopicID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Seq != 0 {
		n += 1 + sovPb(uint64(m.Seq))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArgChangeOwner) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TopicID != 0 {
		n += 1 + sovPb(uint64(m.TopicID))
	}
	if m.ToAccountID != 0 {
		n += 1 + sovPb(uint64(m.ToAccountID))
	}
	if m.Aid != 0 {
		n += 1 + sovPb(uint64(m.Aid))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArgCreateTopic) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Aid != 0 {
		n += 1 + sovPb(uint64(m.Aid))
	}
	if m.Avatar != nil {
		n += m.Avatar.Size()
	}
	if m.Bg != nil {
		n += m.Bg.Size()
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Introduction)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.CatalogViewType)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.AllowDiscuss {
		n += 2
	}
	if m.AllowChat {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArgCreateTopic_AvatarValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AvatarValue)
	n += 1 + l + sovPb(uint64(l))
	return n
}
func (m *ArgCreateTopic_BgValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BgValue)
	n += 1 + l + sovPb(uint64(l))
	return n
}
func (m *ArgUpdateTopic) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovPb(uint64(m.ID))
	}
	if m.Avatar != nil {
		n += m.Avatar.Size()
	}
	if m.Bg != nil {
		n += m.Bg.Size()
	}
	if m.Name != nil {
		n += m.Name.Size()
	}
	if m.Introduction != nil {
		n += m.Introduction.Size()
	}
	if m.CatalogViewType != nil {
		n += m.CatalogViewType.Size()
	}
	if m.AllowChat != nil {
		n += m.AllowChat.Size()
	}
	if m.AllowDiscuss != nil {
		n += m.AllowDiscuss.Size()
	}
	if m.IsPrivate != nil {
		n += m.IsPrivate.Size()
	}
	if m.ViewPermission != nil {
		n += m.ViewPermission.Size()
	}
	if m.EditPermission != nil {
		n += m.EditPermission.Size()
	}
	if m.JoinPermission != nil {
		n += m.JoinPermission.Size()
	}
	if m.Important != nil {
		n += m.Important.Size()
	}
	if m.MuteNotification != nil {
		n += m.MuteNotification.Size()
	}
	if m.Aid != 0 {
		n += 1 + sovPb(uint64(m.Aid))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArgUpdateTopic_AvatarValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AvatarValue)
	n += 1 + l + sovPb(uint64(l))
	return n
}
func (m *ArgUpdateTopic_BgValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BgValue)
	n += 1 + l + sovPb(uint64(l))
	return n
}
func (m *ArgUpdateTopic_NameValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NameValue)
	n += 1 + l + sovPb(uint64(l))
	return n
}
func (m *ArgUpdateTopic_IntroductionValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.IntroductionValue)
	n += 1 + l + sovPb(uint64(l))
	return n
}
func (m *ArgUpdateTopic_CatalogViewTypeValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CatalogViewTypeValue)
	n += 1 + l + sovPb(uint64(l))
	return n
}
func (m *ArgUpdateTopic_AllowChatValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *ArgUpdateTopic_AllowDiscussValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *ArgUpdateTopic_IsPrivateValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *ArgUpdateTopic_ViewPermissionValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ViewPermissionValue)
	n += 1 + l + sovPb(uint64(l))
	return n
}
func (m *ArgUpdateTopic_EditPermissionValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.EditPermissionValue)
	n += 1 + l + sovPb(uint64(l))
	return n
}
func (m *ArgUpdateTopic_JoinPermissionValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.JoinPermissionValue)
	n += 1 + l + sovPb(uint64(l))
	return n
}
func (m *ArgUpdateTopic_ImportantValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *ArgUpdateTopic_MuteNotificationValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *TopicMembersPagedResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Count != 0 {
		n += 1 + sovPb(uint64(m.Count))
	}
	if m.PageSize != 0 {
		n += 1 + sovPb(uint64(m.PageSize))
	}
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArgBatchSavedTopicMember) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TopicID != 0 {
		n += 1 + sovPb(uint64(m.TopicID))
	}
	if len(m.Members) > 0 {
		for _, e := range m.Members {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.Aid != 0 {
		n += 1 + sovPb(uint64(m.Aid))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArgTopicMember) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AccountID != 0 {
		n += 1 + sovPb(uint64(m.AccountID))
	}
	l = len(m.Role)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Opt)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArgTopicCatalog) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != nil {
		n += m.ID.Size()
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Seq != 0 {
		n += 1 + sovPb(uint64(m.Seq))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.RefID != 0 {
		n += 1 + sovPb(uint64(m.RefID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArgTopicCatalog_IDValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPb(uint64(m.IDValue))
	return n
}
func (m *ArgCanEditTopicsReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pn != 0 {
		n += 1 + sovPb(uint64(m.Pn))
	}
	if m.Ps != 0 {
		n += 1 + sovPb(uint64(m.Ps))
	}
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CanEditTopicsResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.Paging != nil {
		l = m.Paging.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CanEditTopicItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovPb(uint64(m.ID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Avatar)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Introduction)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.MemberCount != 0 {
		n += 1 + sovPb(uint64(m.MemberCount))
	}
	if m.ArticleCount != 0 {
		n += 1 + sovPb(uint64(m.ArticleCount))
	}
	if m.DiscussionCount != 0 {
		n += 1 + sovPb(uint64(m.DiscussionCount))
	}
	l = len(m.EditPermission)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.HasCatalogTaxonomy {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Paging) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Total != 0 {
		n += 1 + sovPb(uint64(m.Total))
	}
	if m.IsEnd {
		n += 2
	}
	l = len(m.Next)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Prev)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArgSaveAuthTopics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TopicID != 0 {
		n += 1 + sovPb(uint64(m.TopicID))
	}
	if len(m.AuthTopics) > 0 {
		for _, e := range m.AuthTopics {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.Aid != 0 {
		n += 1 + sovPb(uint64(m.Aid))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArgAuthTopic) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TopicID != 0 {
		n += 1 + sovPb(uint64(m.TopicID))
	}
	l = len(m.Permission)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AuthTopicsResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CatalogsResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArgSaveCatalogs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TopicID != 0 {
		n += 1 + sovPb(uint64(m.TopicID))
	}
	if m.Aid != 0 {
		n += 1 + sovPb(uint64(m.Aid))
	}
	if m.ParentID != 0 {
		n += 1 + sovPb(uint64(m.ParentID))
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArgTopicFollow) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TopicID != 0 {
		n += 1 + sovPb(uint64(m.TopicID))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.AllowViewCert {
		n += 2
	}
	if m.Aid != 0 {
		n += 1 + sovPb(uint64(m.Aid))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArgAuditFollow) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovPb(uint64(m.ID))
	}
	if m.Approve {
		n += 2
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Aid != 0 {
		n += 1 + sovPb(uint64(m.Aid))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StatusResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovPb(uint64(m.Status))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArgTopicInvite) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TopicID != 0 {
		n += 1 + sovPb(uint64(m.TopicID))
	}
	if m.AccountID != 0 {
		n += 1 + sovPb(uint64(m.AccountID))
	}
	if m.Aid != 0 {
		n += 1 + sovPb(uint64(m.Aid))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArgProcessInvite) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovPb(uint64(m.ID))
	}
	if m.Result {
		n += 2
	}
	if m.Aid != 0 {
		n += 1 + sovPb(uint64(m.Aid))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BoolResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArgIsTopicMember) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AccountID != 0 {
		n += 1 + sovPb(uint64(m.AccountID))
	}
	if m.TopicID != 0 {
		n += 1 + sovPb(uint64(m.TopicID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArgHasInvite) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AccountID != 0 {
		n += 1 + sovPb(uint64(m.AccountID))
	}
	if m.TopicID != 0 {
		n += 1 + sovPb(uint64(m.TopicID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovPb(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPb(x uint64) (n int) {
	return sovPb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EmptyStruct) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EmptyStruct: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EmptyStruct: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemberRoleReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemberRoleReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemberRoleReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsMember", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsMember = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Role = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Creator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Creator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Creator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Avatar", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Avatar = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Introduction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Introduction = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopicInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopicInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopicInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Avatar", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Avatar = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Introduction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Introduction = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowDiscuss", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowDiscuss = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowChat", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowChat = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPrivate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPrivate = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ViewPermission", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ViewPermission = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EditPermission", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EditPermission = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinPermission", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JoinPermission = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CatalogViewType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CatalogViewType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicHome", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TopicHome = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Creator == nil {
				m.Creator = &Creator{}
			}
			if err := m.Creator.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			m.UpdatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stat == nil {
				m.Stat = &TopicStat{}
			}
			if err := m.Stat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopicRootCatalogInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopicRootCatalogInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopicRootCatalogInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefID", wireType)
			}
			m.RefID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Article", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Article == nil {
				m.Article = &TargetArticle{}
			}
			if err := m.Article.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Children = append(m.Children, &TopicParentCatalogInfo{})
			if err := m.Children[len(m.Children)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopicParentCatalogInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopicParentCatalogInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopicParentCatalogInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefID", wireType)
			}
			m.RefID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Article", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Article == nil {
				m.Article = &TargetArticle{}
			}
			if err := m.Article.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Children = append(m.Children, &TopicChildCatalogInfo{})
			if err := m.Children[len(m.Children)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopicChildCatalogInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopicChildCatalogInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopicChildCatalogInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefID", wireType)
			}
			m.RefID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Article", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Article == nil {
				m.Article = &TargetArticle{}
			}
			if err := m.Article.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TargetArticle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TargetArticle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TargetArticle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Excerpt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Excerpt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageUrls", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageUrls = append(m.ImageUrls, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LikeCount", wireType)
			}
			m.LikeCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LikeCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DislikeCount", wireType)
			}
			m.DislikeCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DislikeCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReviseCount", wireType)
			}
			m.ReviseCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReviseCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommentCount", wireType)
			}
			m.CommentCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommentCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			m.UpdatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Creator == nil {
				m.Creator = &Creator{}
			}
			if err := m.Creator.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopicStat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopicStat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopicStat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemberCount", wireType)
			}
			m.MemberCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemberCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArticleCount", wireType)
			}
			m.ArticleCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArticleCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscussionCount", wireType)
			}
			m.DiscussionCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiscussionCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopicMetaInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopicMetaInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopicMetaInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanFollow", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanFollow = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanEdit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanEdit = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fav", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Fav = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanView", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanView = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FollowStatus", wireType)
			}
			m.FollowStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FollowStatus |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsMember", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsMember = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemberRole", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MemberRole = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopicPermissionInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopicPermissionInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopicPermissionInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EditPermission", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EditPermission = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsMember", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsMember = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemberRole", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MemberRole = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopicReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopicReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopicReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseMaster", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseMaster = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopicMetaReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopicMetaReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopicMetaReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicID", wireType)
			}
			m.TopicID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountID", wireType)
			}
			m.AccountID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccountID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseMaster", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseMaster = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopicMemberRoleReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopicMemberRoleReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopicMemberRoleReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicID", wireType)
			}
			m.TopicID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountID", wireType)
			}
			m.AccountID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccountID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseMaster", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseMaster = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopicPermissionReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopicPermissionReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopicPermissionReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicID", wireType)
			}
			m.TopicID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountID", wireType)
			}
			m.AccountID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccountID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseMaster", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseMaster = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserTopicsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserTopicsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserTopicsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountID", wireType)
			}
			m.AccountID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccountID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserTopicsResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserTopicsResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserTopicsResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &TopicInfo{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllTopicsResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllTopicsResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllTopicsResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &TopicInfo{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AidReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AidReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AidReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountID", wireType)
			}
			m.AccountID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccountID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseMaster", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseMaster = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IDsResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IDsResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IDsResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.IDs = append(m.IDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.IDs) == 0 {
					m.IDs = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.IDs = append(m.IDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field IDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IDReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IDReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IDReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Include", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Include = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aid", wireType)
			}
			m.Aid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IDResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IDResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IDResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopicResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopicResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopicResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Avatar", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Avatar = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Introduction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Introduction = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowDiscuss", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowDiscuss = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowChat", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowChat = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPrivate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPrivate = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ViewPermission", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ViewPermission = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EditPermission", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EditPermission = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinPermission", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JoinPermission = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CatalogViewType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CatalogViewType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicHome", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TopicHome = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Creator == nil {
				m.Creator = &Creator{}
			}
			if err := m.Creator.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			m.UpdatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MuteNotification", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MuteNotification = bool(v != 0)
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Important", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Important = bool(v != 0)
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stat == nil {
				m.Stat = &TopicStat{}
			}
			if err := m.Stat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasCatalogTaxonomy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasCatalogTaxonomy = bool(v != 0)
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Members = append(m.Members, &TopicMemberInfo{})
			if err := m.Members[len(m.Members)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Catalogs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Catalogs = append(m.Catalogs, &TopicRootCatalogInfo{})
			if err := m.Catalogs[len(m.Catalogs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscussCategories", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DiscussCategories = append(m.DiscussCategories, &DiscussCategoryInfo{})
			if err := m.DiscussCategories[len(m.DiscussCategories)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthTopics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthTopics = append(m.AuthTopics, &AuthTopicInfo{})
			if err := m.AuthTopics[len(m.AuthTopics)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TopicMeta == nil {
				m.TopicMeta = &TopicMetaInfo{}
			}
			if err := m.TopicMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopicMemberInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopicMemberInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopicMemberInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountID", wireType)
			}
			m.AccountID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccountID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Role = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Avatar", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Avatar = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthTopicInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthTopicInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthTopicInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToTopicID", wireType)
			}
			m.ToTopicID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToTopicID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EditPermission", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EditPermission = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permission", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Permission = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemberCount", wireType)
			}
			m.MemberCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemberCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Avatar", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Avatar = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiscussCategoryInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiscussCategoryInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiscussCategoryInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicID", wireType)
			}
			m.TopicID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArgChangeOwner) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArgChangeOwner: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArgChangeOwner: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicID", wireType)
			}
			m.TopicID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToAccountID", wireType)
			}
			m.ToAccountID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToAccountID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aid", wireType)
			}
			m.Aid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArgCreateTopic) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArgCreateTopic: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArgCreateTopic: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aid", wireType)
			}
			m.Aid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvatarValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Avatar = &ArgCreateTopic_AvatarValue{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bg = &ArgCreateTopic_BgValue{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Introduction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Introduction = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CatalogViewType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CatalogViewType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowDiscuss", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowDiscuss = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowChat", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowChat = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArgUpdateTopic) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArgUpdateTopic: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArgUpdateTopic: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvatarValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Avatar = &ArgUpdateTopic_AvatarValue{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bg = &ArgUpdateTopic_BgValue{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = &ArgUpdateTopic_NameValue{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntroductionValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Introduction = &ArgUpdateTopic_IntroductionValue{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CatalogViewTypeValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CatalogViewType = &ArgUpdateTopic_CatalogViewTypeValue{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowChatValue", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.AllowChat = &ArgUpdateTopic_AllowChatValue{b}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowDiscussValue", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.AllowDiscuss = &ArgUpdateTopic_AllowDiscussValue{b}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPrivateValue", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsPrivate = &ArgUpdateTopic_IsPrivateValue{b}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ViewPermissionValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ViewPermission = &ArgUpdateTopic_ViewPermissionValue{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EditPermissionValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EditPermission = &ArgUpdateTopic_EditPermissionValue{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinPermissionValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JoinPermission = &ArgUpdateTopic_JoinPermissionValue{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImportantValue", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Important = &ArgUpdateTopic_ImportantValue{b}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MuteNotificationValue", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.MuteNotification = &ArgUpdateTopic_MuteNotificationValue{b}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aid", wireType)
			}
			m.Aid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopicMembersPagedResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopicMembersPagedResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopicMembersPagedResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &TopicMemberInfo{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArgBatchSavedTopicMember) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArgBatchSavedTopicMember: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArgBatchSavedTopicMember: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicID", wireType)
			}
			m.TopicID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Members = append(m.Members, &ArgTopicMember{})
			if err := m.Members[len(m.Members)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aid", wireType)
			}
			m.Aid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArgTopicMember) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArgTopicMember: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArgTopicMember: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountID", wireType)
			}
			m.AccountID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccountID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Role = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Opt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArgTopicCatalog) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArgTopicCatalog: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArgTopicCatalog: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IDValue", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ID = &ArgTopicCatalog_IDValue{v}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefID", wireType)
			}
			m.RefID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArgCanEditTopicsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArgCanEditTopicsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArgCanEditTopicsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pn", wireType)
			}
			m.Pn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pn |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ps", wireType)
			}
			m.Ps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ps |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CanEditTopicsResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CanEditTopicsResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CanEditTopicsResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &CanEditTopicItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paging", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Paging == nil {
				m.Paging = &Paging{}
			}
			if err := m.Paging.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CanEditTopicItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CanEditTopicItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CanEditTopicItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Avatar", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Avatar = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Introduction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Introduction = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemberCount", wireType)
			}
			m.MemberCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemberCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArticleCount", wireType)
			}
			m.ArticleCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArticleCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscussionCount", wireType)
			}
			m.DiscussionCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiscussionCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EditPermission", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EditPermission = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasCatalogTaxonomy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasCatalogTaxonomy = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Paging) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Paging: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Paging: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsEnd", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsEnd = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Next", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Next = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prev", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prev = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArgSaveAuthTopics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArgSaveAuthTopics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArgSaveAuthTopics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicID", wireType)
			}
			m.TopicID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthTopics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthTopics = append(m.AuthTopics, &ArgAuthTopic{})
			if err := m.AuthTopics[len(m.AuthTopics)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aid", wireType)
			}
			m.Aid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArgAuthTopic) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArgAuthTopic: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArgAuthTopic: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicID", wireType)
			}
			m.TopicID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permission", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Permission = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthTopicsResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthTopicsResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthTopicsResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &AuthTopicInfo{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CatalogsResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CatalogsResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CatalogsResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &TopicRootCatalogInfo{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArgSaveCatalogs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArgSaveCatalogs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArgSaveCatalogs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicID", wireType)
			}
			m.TopicID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aid", wireType)
			}
			m.Aid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentID", wireType)
			}
			m.ParentID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParentID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &ArgTopicCatalog{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArgTopicFollow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArgTopicFollow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArgTopicFollow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicID", wireType)
			}
			m.TopicID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowViewCert", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowViewCert = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aid", wireType)
			}
			m.Aid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArgAuditFollow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArgAuditFollow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArgAuditFollow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Approve", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Approve = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aid", wireType)
			}
			m.Aid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatusResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatusResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatusResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArgTopicInvite) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArgTopicInvite: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArgTopicInvite: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicID", wireType)
			}
			m.TopicID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountID", wireType)
			}
			m.AccountID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccountID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aid", wireType)
			}
			m.Aid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArgProcessInvite) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArgProcessInvite: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArgProcessInvite: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aid", wireType)
			}
			m.Aid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BoolResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BoolResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BoolResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArgIsTopicMember) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArgIsTopicMember: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArgIsTopicMember: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountID", wireType)
			}
			m.AccountID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccountID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicID", wireType)
			}
			m.TopicID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArgHasInvite) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArgHasInvite: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArgHasInvite: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountID", wireType)
			}
			m.AccountID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccountID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicID", wireType)
			}
			m.TopicID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPb
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthPb
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowPb
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipPb(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthPb
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthPb = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPb   = fmt.Errorf("proto: integer overflow")
)
